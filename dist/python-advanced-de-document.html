<h1>Python Fortgeschritten</h1>
<h2>Themen</h2>
<ul>
<li>Logging</li>
<li>automatisiertes Testen</li>
<li>Typenannotationen</li>
<li>fortgeschrittene objektorientierte Programmierung
<ul>
<li>Properties</li>
<li>statische Attribute und Methoden</li>
<li>magic Methods</li>
<li>Vererbung</li>
</ul>
</li>
<li>Iterators</li>
<li>Lambdas</li>
<li>Higher-order Functions</li>
<li>weitere Datentypen: set, namedtuple, enum</li>
<li>Parallelisierung: threads und multiprocessing</li>
</ul>
<h1>Logging</h1>
<h2>Logging</h2>
<p>lange laufende Programme können ihren Ablauf in Log-Dateien dokumentieren</p>
<p>z.B.: lange laufende Algorithmen, Webserver</p>
<h2>Logging</h2>
<pre><code class="hljs language-py"><span class="hljs-keyword">import</span> logging
logging.basicConfig(
    filename=<span class="hljs-string">"sort.log"</span>,
    level=logging.DEBUG,
    filemode=<span class="hljs-string">"w"</span>
)

logging.debug(<span class="hljs-string">"hello"</span>)
</code></pre>
<h2>Logging</h2>
<p>Übung: Hinzufügen von Logging zu einer bestehenden Funktion (z.B. zu einem Sortieralgorithmus)</p>
<h1>Automatisiertes Testen</h1>
<h2>Automatisiertes Testen</h2>
<p>warum:</p>
<ul>
<li>sicher stellen, dass Code wie erwünscht funktioniert</li>
<li>einfacheres Refactoring / Ändern des Codes ohne Schaden zu verursachen</li>
<li>Dokumentation von erwartetem Verhalten</li>
</ul>
<h2>Testtools</h2>
<p><strong>pytest</strong>: Testlibrary mit einfachem Interface</p>
<p><strong>doctest</strong>: Überprüft Codebeispiele in Docstrings</p>
<p><strong>unittest</strong>: Testlibrary, die in der Standardlibrary beinhaltet ist</p>
<h2>Beispiel: zu testender Code</h2>
<p>zu testender Code:</p>
<pre><code class="hljs language-py"><span class="hljs-comment"># insertion_sort.py</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertion_sort</span>(<span class="hljs-params">unsorted</span>):</span>
    <span class="hljs-string">"""Return a sorted version of a list."""</span>
    <span class="hljs-built_in">sorted</span> = []
    <span class="hljs-keyword">for</span> new_item <span class="hljs-keyword">in</span> unsorted:
        i = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> sorted_item <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>:
            <span class="hljs-keyword">if</span> new_item >= sorted_item:
                i += <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">break</span>
        <span class="hljs-built_in">sorted</span>.insert(i, new_item)
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>
</code></pre>
<h2>assert</h2>
<p><em>assert</em>: Keyword, das sicherstellt, dass eine bestimmte Bedingung eintrifft</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(a, <span class="hljs-built_in">int</span>)
<span class="hljs-keyword">assert</span> a > <span class="hljs-number">0</span>
</code></pre>
<p>Bei Nichterfüllen wird ein <em>assertion error</em> ausgelöst</p>
<h2>Beispiel: Menuelle Tests mit assert</h2>
<pre><code class="hljs language-py"><span class="hljs-comment"># insertion_sort_test.py</span>
<span class="hljs-keyword">from</span> insertion_sort <span class="hljs-keyword">import</span> insertion_sort

<span class="hljs-keyword">assert</span> insertion_sort([<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>]) == [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-keyword">assert</span> insertion_sort([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]) == [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
<span class="hljs-keyword">assert</span> insertion_sort([]) == []
</code></pre>
<p>Das Skript sollte ohne Fehler laufen</p>
<h1>Pytest</h1>
<h2>Pytest</h2>
<p>Test-Library mit einfachem Interface, basierend auf <code>assert</code></p>
<pre><code class="hljs language-cmake">pip <span class="hljs-keyword">install</span> pytest
</code></pre>
<h2>Pytest</h2>
<p>Testdatei für pytest:</p>
<pre><code class="hljs language-py"><span class="hljs-comment"># insertion_sort_test.py</span>
<span class="hljs-keyword">from</span> insertion_sort <span class="hljs-keyword">import</span> insertion_sort

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_insertion_sort</span>():</span>
    <span class="hljs-keyword">assert</span> insertion_sort([<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>]) == [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
    <span class="hljs-keyword">assert</span> insertion_sort([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]) == [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
    <span class="hljs-keyword">assert</span> insertion_sort([]) == []
</code></pre>
<p>Finden und Ausführen von Tests:</p>
<pre><code class="hljs language-bash">python -m pytest
</code></pre>
<h2>Bericht</h2>
<pre><code class="hljs language-excel">=================== test session starts ===================
platform win32 -- Python <span class="hljs-number">3.8</span>.<span class="hljs-number">7</span>, pytest-<span class="hljs-number">6.2</span>.<span class="hljs-number">1</span>, [...]
rootd<span class="hljs-symbol">ir:</span> <span class="hljs-symbol">C:</span>\[...]
collected <span class="hljs-number">1</span> item

insertion_sort_test.py .                             [<span class="hljs-number">100%</span>]

==================== <span class="hljs-number">1</span> passed in <span class="hljs-number">0.19</span>s ====================
</code></pre>
<h2>Test discovery</h2>
<p>Namensgebung für Dateien: <code>*_test.py</code> (oder <code>test_*.py</code>)</p>
<p>Namensgebung für Funktionen: <code>test*</code></p>
<h2>Abdeckung</h2>
<p>Bestimmen, wie viel des Codes von Tests abgedeckt ist (welcher Anteil an Statements wird ausgeführt):</p>
<pre><code class="hljs language-bash">pip install pytest-cov
</code></pre>
<pre><code class="hljs language-bash">python -m pytest -cov=.
</code></pre>
<p>example output:</p>
<pre><code class="hljs language-asciidoc"><span class="hljs-section">Name                     Stmts   Miss  Cover
--------------------------------------------</span>
insertion<span class="hljs-emphasis">_sort.py           10      0   100%
insertion_</span>sort<span class="hljs-emphasis">_test.py       5      0   100%
--------------------------------------------
TOTAL                       15      0   100%
</span></code></pre>
<h2>Testen von Exceptions</h2>
<pre><code class="hljs language-py"><span class="hljs-keyword">import</span> pytest

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_no_argument_raises</span>():</span>
    <span class="hljs-keyword">with</span> pytest.raises(TypeError):
        insertion_sort()
</code></pre>
<h2>Gruppierung</h2>
<p>Gruppieren von Tests via Klassen:</p>
<pre><code class="hljs language-py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestExceptions</span>():</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_no_argument_raises</span>():</span>
        <span class="hljs-keyword">with</span> pytest.raises(TypeError):
            insertion_sort()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_different_types_raises</span>():</span>
        <span class="hljs-keyword">with</span> pytest.raises(TypeError):
            insertion_sort([<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>])
</code></pre>
<h2>Fixtures</h2>
<p><em>Fixtures</em> können bestimmte Bedingungen vor dem durchführen eines Tests herstellen</p>
<pre><code class="hljs language-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_foo</span>(<span class="hljs-params">tmp_path</span>):</span>
    <span class="hljs-comment"># tmp_path is a path to a temporary directory</span>
</code></pre>
<p>verfügbare Fixtures:</p>
<ul>
<li><code>tmp_path</code></li>
<li><code>capsys</code> (überwacht Output in <em>stdout</em> und <em>stderr</em>)</li>
<li>... (<a href="https://docs.pytest.org/en/stable/fixture.html">siehe Dokumentation</a>)</li>
</ul>
<h2>Ressourcen</h2>
<ul>
<li><a href="https://docs.pytest.org/en/stable/getting-started.html#run-multiple-tests">pytest: Installation and Getting Started</a></li>
<li><a href="https://docs.pytest.org/">pytest Dokumentation</a></li>
</ul>
<h1>Doctests</h1>
<h2>Doctests</h2>
<p>Codebeispiele können in Docstrings beinhaltet sein und zum Testen verwendet werden</p>
<h2>Doctests</h2>
<p>einfacher Doctest:</p>
<pre><code class="hljs language-py"><span class="hljs-comment"># insertion_sort.py</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insertion_sort</span>(<span class="hljs-params">unsorted</span>):</span>
    <span class="hljs-string">"""Return a sorted version of a list.

    >>> insertion_sort([3, 2, 4, 1, 5])
    [1, 2, 3, 4, 5]
    """</span>

    <span class="hljs-comment"># code here</span>
</code></pre>
<h2>Ausführen von Doctests</h2>
<p>Ausführen von Doctests aus pytest:</p>
<pre><code class="hljs language-bash">python -m pytest --doctest-modules
</code></pre>
<h2>Lange Ausgaben</h2>
<pre><code class="hljs language-py"><span class="hljs-string">"""
<span class="hljs-meta">>>> </span>insertion_sort(range(10)) #doctest: +NORMALIZE_WHITESPACE
[0, 1, 2, 3, 4, 5,
6, 7, 8, 9]
<span class="hljs-meta">>>> </span>insertion_sort(range(10)) #doctest: +ELLIPSIS
[0, 1, 2, ..., 8, 9]
"""</span>
</code></pre>
<h1>Unittest</h1>
<h2>Unittest</h2>
<p><em>unittest</em>: Testpaket in der Standardlibrary</p>
<p>oft wird stattdessen <em>pytest</em> empfohlen</p>
<h2>Test discovery</h2>
<pre><code class="hljs language-bash">python -m unittest
</code></pre>
<p>Sucht nach dem Namensschema <code>test_*.py*</code></p>
<p>Bemerkung: Unterordner mit Tests müssen eine datei namens <em>__init__.py</em> beinhalten (siehe <a href="https://bugs.python.org/issue35617">https://bugs.python.org/issue35617</a>)</p>
<p>nach einem anderen Schema suchen:</p>
<pre><code class="hljs language-bash">python -m unittest discover -p <span class="hljs-string">"*_test.py"</span>
</code></pre>
<h2>Schreiben von Tests</h2>
<pre><code class="hljs language-py"><span class="hljs-comment"># insertion_sort_test.py</span>
<span class="hljs-keyword">import</span> unittest

<span class="hljs-keyword">import</span> insertion_sort

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InsertionSort</span>(<span class="hljs-params">unittest.TestCase</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_five_items</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-built_in">input</span> = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>]
        expected = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
        actual = insertion_sort.insertion_sort(<span class="hljs-built_in">input</span>)
        self.assertEqual(actual, expected)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_empty</span>(<span class="hljs-params">self</span>):</span>
        actual = insertion_sort.insertion_sort([])
        self.assertEqual(actual, [])
</code></pre>
<h2>Assertions</h2>
<p>Assertions:</p>
<ul>
<li><code>.assertEqual(a, 3)</code></li>
<li><code>.assertTrue(b)</code></li>
<li><code>.assertFalse(c)</code></li>
<li><code>.assertIsNone(d)</code></li>
<li><code>.assertIn(a, [2, 3, 4])</code></li>
<li><code>.assertIsInstance(a, int)</code></li>
<li><code>.assertRaises(TypeError, len)</code></li>
<li>...</li>
</ul>
<p>es gibt auch gegenteilige Assertions, z.B. <code>.assertNotEqual(a, 3)</code></p>
<h2>setUp and tearDown</h2>
<p>Definieren von Funktionen, die vor / nach jedem Test ausgeführt werden:</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">import</span> unittest

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetTestCase</span>(<span class="hljs-params">unittest.TestCase</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setUp</span>(<span class="hljs-params">self</span>):</span>
        self.widget = Widget(<span class="hljs-string">'The widget'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tearDown</span>(<span class="hljs-params">self</span>):</span>
        self.widget.dispose()
</code></pre>
<h2>Testabdeckung</h2>
<p>PIP-Paket <em>coverage</em></p>
<p>ausführen:</p>
<pre><code class="hljs language-bash">python -m coverage run test_shorten.py
python -m coverage report
</code></pre>
<p>mögliche Ausgabe:</p>
<pre><code class="hljs language-asciidoc"><span class="hljs-section">Name              Stmts   Miss  Cover
-------------------------------------</span>
shorten.py            4      0   100%
<span class="hljs-section">test_shorten.py      11      0   100%
-------------------------------------</span>
TOTAL                15      0   100%
</code></pre>
<h2>Ausführen von Doctests</h2>
<pre><code class="hljs language-py"><span class="hljs-comment"># insertion_sort_test.py</span>
<span class="hljs-keyword">import</span> doctest

<span class="hljs-keyword">import</span> insertion_sort

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_tests</span>(<span class="hljs-params">loader, tests, ignore</span>):</span>
    tests.addTests(doctest.DocTestSuite(insertion_sort))
    <span class="hljs-keyword">return</span> tests
</code></pre>
<h1>Docstrings</h1>
<h2>Docstrings anzeigen</h2>
<p>aus der interaktiven Konsole:</p>
<pre><code class="hljs language-py"><span class="hljs-built_in">help</span>(<span class="hljs-built_in">round</span>)
<span class="hljs-keyword">import</span> math
<span class="hljs-built_in">help</span>(math)
<span class="hljs-built_in">help</span>(math.floor)
</code></pre>
<p>aus dem Terminal:</p>
<pre><code class="hljs language-bash">python -m pydoc round
python -m pydoc math
python -m pydoc math.floor
</code></pre>
<h2>Docstring-Format</h2>
<p>PEP 257: <a href="https://www.python.org/dev/peps/pep-0257/">https://www.python.org/dev/peps/pep-0257/</a></p>
<h2>Docstrig-Format</h2>
<p>Docstring eines Moduls: Beschreibung, Liste exportierter Funktionen mit einzeiligen Zusammenfassungen</p>
<p>Docstring einer Klasse: Beschreibung, Liste der Methoden</p>
<p>Docstring einer Funktion: Beschreibung, Liste der Parameter</p>
<h2>Pydocstyle</h2>
<p>Linter zum Validieren von Docstrings</p>
<h2>reStructuredText und Sphinx</h2>
<p><em>reStructuredText (reST)</em> = einfache Auszeichnungssprache (ähnlich zu <em>Markdown</em>), die in Python Docstrings verwendet werden kann</p>
<p><em>Sphinx</em> = Werkzeug, das aus bestehenden Docstrings Dokumentation in HTML und ähnlichen Formaten generiert</p>
<h2>reStructuredText</h2>
<p>Beispiel</p>
<pre><code class="hljs language-rest">Heading
=======

- list item 1
- list item 2

Link to `Wikipedia`_.

.. _Wikipedia: https://www.wikipedia.org/

.. code:: python

   print("hello")
</code></pre>
<h1>Type Hints</h1>
<h2>Type Hints</h2>
<p>Neuere Versionen von Python unterstützen optionale Typenannotationen</p>
<p>Typenannotationen können die IDE - z.B. durch das Bereitstellen zusätzlicher Fehlermeldungen</p>
<h2>Typechecker</h2>
<ul>
<li>pyright</li>
<li>mypy</li>
</ul>
<p>VS Code Extensions für beide verfügbar</p>
<h2>Variablen</h2>
<p>Variablen:</p>
<pre><code class="hljs language-py">i: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span>
</code></pre>
<h2>Funktionen</h2>
<p>Funktionen:</p>
<pre><code class="hljs language-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">double</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -> int:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * n
</code></pre>
<h2>Kollektionen</h2>
<pre><code class="hljs language-py"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List, Set, Dict, Tuple

names: List[<span class="hljs-built_in">str</span>] = [<span class="hljs-string">'Anna'</span>, <span class="hljs-string">'Bernd'</span>, <span class="hljs-string">'Caro'</span>]
person: Tuple[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>] = (<span class="hljs-string">'Anna'</span>, <span class="hljs-string">'Berger'</span>, <span class="hljs-number">1990</span>)
roman_numerals: Dict[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>] = {<span class="hljs-number">1</span>: <span class="hljs-string">'I'</span>, <span class="hljs-number">2</span>: <span class="hljs-string">'II'</span>, <span class="hljs-number">3</span>: <span class="hljs-string">'III'</span>, <span class="hljs-number">4</span>: <span class="hljs-string">'IV'</span>}
</code></pre>
<pre><code class="hljs language-py"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Iterable

names: Iterable[<span class="hljs-built_in">str</span>] = ...
</code></pre>
<h1>Fortgeschrittene objektorientierte Programmierung</h1>
<h2>Fortgeschrittene objektorientierte Programmierung</h2>
<p>Beispiel: Klasse <em>Length</em></p>
<pre><code class="hljs language-py">a = Length(<span class="hljs-number">130</span>, <span class="hljs-string">"cm"</span>)
a.value <span class="hljs-comment"># 130</span>
a.unit <span class="hljs-comment"># cm</span>
a.unit = <span class="hljs-string">"in"</span>
a.value <span class="hljs-comment"># 51.18</span>
<span class="hljs-built_in">str</span>(a) <span class="hljs-comment"># 51.18in</span>
b = Length.from_string(<span class="hljs-string">"12cm"</span>)
<span class="hljs-number">2</span> * b <span class="hljs-comment"># 24cm</span>
b + a <span class="hljs-comment"># 142cm</span>
</code></pre>
<h1>OOP: Properties</h1>
<h2>Properties</h2>
<p>Getter &#x26; Setter (in Python unüblich, in anderen Sprachen verbreitet):</p>
<pre><code class="hljs language-py">r = Rectangle(length=<span class="hljs-number">3</span>, width=<span class="hljs-number">4</span>)
print(r.get_area()) <span class="hljs-comment"># 12</span>
r.set_length(<span class="hljs-number">4</span>)
print(r.get_area()) <span class="hljs-comment"># 16</span>
</code></pre>
<p>Mit Properties in Python:</p>
<pre><code class="hljs language-py">r = Rectangle(length=<span class="hljs-number">3</span>, width=<span class="hljs-number">4</span>)
print(r.area) <span class="hljs-comment"># 12</span>
r.length = <span class="hljs-number">4</span>
print(r.area) <span class="hljs-comment"># 16</span>
</code></pre>
<h2>Properties</h2>
<p>Übung: Umsetzen einer Klasse <code>Rectangle_gs</code> mit Gettern und Settern</p>
<h2>Properties</h2>
<pre><code class="hljs language-py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle_gs</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, length, width</span>):</span>
        self._length = length
        self._width = width

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_length</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">return</span> self._length

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_length</span>(<span class="hljs-params">self, new_length</span>):</span>
        self._length = new_length

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_width</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">return</span> self._width

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_width</span>(<span class="hljs-params">self, new_width</span>):</span>
        self._width = new_width

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_area</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">return</span> self._length * self._width
</code></pre>
<h2>Properties</h2>
<p>Mit Properties können wir das Auslesen oder Setzen von Attributen über eine Funktion "umleiten" - es kann also der Zugriff auf <code>r.area</code> im Hintergrund zum Ausführen einer Getter- oder Setterfunktion führen.</p>
<h2>Properties</h2>
<pre><code class="hljs language-py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, length, width</span>):</span>
        self.length = length
        self.width = width

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_area</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">return</span> self.length * self.width
    
    area = <span class="hljs-built_in">property</span>(_get_area)
</code></pre>
<p><code>property</code> ist ein built-in, also ähnlich wie <code>print</code> immer verfügbar.</p>
<h2>Properties</h2>
<p>Erweiterung: Setter für <em>area</em></p>
<pre><code class="hljs language-py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>:</span>
    ...

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_set_area</span>(<span class="hljs-params">self, new_area</span>):</span>
        <span class="hljs-comment"># adjust the length</span>
        self.length = new_area / self.width
    
    area = <span class="hljs-built_in">property</span>(_get_area, _set_area)
</code></pre>
<h2>Properties</h2>
<p>Alternative Schreibweise mit Decorators:</p>
<pre><code class="hljs language-py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, length, width</span>):</span>
        self.length = length
        self.width = width

<span class="hljs-meta">    @property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">area</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">return</span> self.length * self.width
    
<span class="hljs-meta">    @area.setter</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">area</span>(<span class="hljs-params">self, new_area</span>):</span>
        self.length = new_area / self.width
</code></pre>
<h1>OOP: Statische Attribute und Methoden</h1>
<h2>Statische Attribute und Methoden</h2>
<p><em>Statische Attribute</em> und <em>Statische Methoden</em> sind mit einer Klasse assoziiert, jedoch nicht mit einer spezifischen Instanz davon</p>
<p>Beispiel anhand der <em>datetime</em>-Klasse:</p>
<ul>
<li><code>datetime.today()</code></li>
<li><code>datetime.fromisoformat()</code></li>
<li><code>datetime.resolution</code></li>
</ul>
<h2>Klassenattribute (statische Attribute)</h2>
<p><em>Klassenattribute</em> sind Attribute, die nur auf der Klasse (nicht auf jeder Instanz) definiert sind - alle Instanzen teilen sich die Attribute.</p>
<h2>Klassenattribute (statische Attribute)</h2>
<p>Beispiel <code>Money</code>-Klasse: <code>_currency_data</code> kann von allen Instanzen verwendet werden.</p>
<pre><code class="hljs language-py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Money</span>:</span>
    _currency_data = [
        {<span class="hljs-string">"code"</span>: <span class="hljs-string">"USD"</span>, <span class="hljs-string">"symbol"</span>: <span class="hljs-string">"$"</span>, <span class="hljs-string">"rate"</span>: <span class="hljs-number">1.0</span>},
        {<span class="hljs-string">"code"</span>: <span class="hljs-string">"EUR"</span>, <span class="hljs-string">"symbol"</span>: <span class="hljs-string">"€"</span>, <span class="hljs-string">"rate"</span>: <span class="hljs-number">1.1</span>},
        {<span class="hljs-string">"code"</span>: <span class="hljs-string">"GBP"</span>, <span class="hljs-string">"symbol"</span>: <span class="hljs-string">"£"</span>, <span class="hljs-string">"rate"</span>: <span class="hljs-number">1.25</span>},
        {<span class="hljs-string">"code"</span>: <span class="hljs-string">"JPY"</span>, <span class="hljs-string">"symbol"</span>: <span class="hljs-string">"¥"</span>, <span class="hljs-string">"rate"</span>: <span class="hljs-number">0.01</span>},
    ]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, ...</span>):</span>
        ...
</code></pre>
<h2>Statische Methoden</h2>
<p>Muss eine Methode nicht auf die Daten einer bestimmten Instanz zugreifen, so kann sie als statische Methode deklariert werden.</p>
<pre><code class="hljs language-py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Money</span>:</span>
    ...

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_currency_data</span>(<span class="hljs-params">code</span>):</span>
        <span class="hljs-keyword">for</span> currency <span class="hljs-keyword">in</span> Money._currency_data:
            <span class="hljs-keyword">if</span> code == currency[<span class="hljs-string">"code"</span>]:
                <span class="hljs-keyword">return</span> currency
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f"unknown currency: <span class="hljs-subst">{code}</span>"</span>)
</code></pre>
<p>Beachte: Bei einer statischen Methode wird als erster Parameter nicht <code>self</code> übergeben - die Referenz auf die Instanz ist nicht vorhanden.</p>
<h2>Statische Methoden</h2>
<p>Statische Methoden haben zwei wichtige Anwendungsbereiche:</p>
<ul>
<li>Erstellen von Instanzen: z.B. <code>Money.from_string("23.40EUR")</code></li>
<li>Bündeln von Hilfsfunktionen mit einer Klasse: z.B. <code>_get_currency_data</code></li>
</ul>
<h2>Klassenmethoden</h2>
<p>Um den folgenden Code für Vererbung portabler zu machen, wäre es sinnvoll, den Klassennamen (<code>Money</code>) nicht in der Methodendefinition zu erwähnen:</p>
<pre><code class="hljs language-py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Money</span>:</span>
    ...

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_currency_data</span>(<span class="hljs-params">code</span>):</span>
        <span class="hljs-keyword">for</span> currency <span class="hljs-keyword">in</span> Money._currency_data:
            <span class="hljs-keyword">if</span> code == currency[<span class="hljs-string">"code"</span>]:
                <span class="hljs-keyword">return</span> currency
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f"unknown currency: <span class="hljs-subst">{code}</span>"</span>)
</code></pre>
<h2>Klassenmethoden</h2>
<p>Klassenmethoden sind besondere statische Methoden, die die Möglichkeit bieten, unter einem allgemeinen Namen (üblicherweise <code>cls</code>) auf die Klasse zu verweisen:</p>
<pre><code class="hljs language-py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Money</span>:</span>
    ...

<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_currency_data</span>(<span class="hljs-params">cls, code</span>):</span>
        <span class="hljs-keyword">for</span> currency <span class="hljs-keyword">in</span> cls._currency_data:
            <span class="hljs-keyword">if</span> code == currency[<span class="hljs-string">"code"</span>]:
                <span class="hljs-keyword">return</span> currency
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f"unknown currency: <span class="hljs-subst">{code}</span>"</span>)
</code></pre>
<h1>OOP: Magic Methods</h1>
<h2>Magic Methods</h2>
<p>Besondere Methoden, die das Verhalten einer Klasse beeinflussen</p>
<p>Beginnen und enden mit zwei Unterstrichen, z.B. <code>__init__</code></p>
<p>Liste von magic Methods: <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names">https://docs.python.org/3/reference/datamodel.html#special-method-names</a></p>
<h2>Magic Methods</h2>
<p>Methoden zur Umwandlung in Strings:</p>
<ul>
<li><code>__repr__</code>: möglichst vollständige Informationen zum Objekt, idealerweise von Python interpretierbar</li>
<li><code>__str__</code>: "schön" zu lesen</li>
</ul>
<p>Beispiel:</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> time
a = time(<span class="hljs-number">23</span>, <span class="hljs-number">45</span>)
<span class="hljs-built_in">repr</span>(a) <span class="hljs-comment"># 'datetime.time(23, 45)'</span>
<span class="hljs-built_in">str</span>(a) <span class="hljs-comment"># '23:45:00'</span>
</code></pre>
<h2>Magic Methods</h2>
<p>Methoden für mathematische Operatoren:</p>
<ul>
<li><code>__add__</code></li>
<li><code>__mul__</code></li>
<li><code>__rmul__</code></li>
<li>...</li>
</ul>
<h2>Magic Methods</h2>
<ul>
<li><code>__call__</code></li>
<li><code>__getitem__</code></li>
</ul>
<h1>OOP: Vererbung</h1>
<h2>Unterklassen und Vererbungsreihenfolge</h2>
<h2>super()</h2>
<p>Proxy zu den Elternklassen</p>
<h2>super()</h2>
<p>ohne super:</p>
<pre><code class="hljs language-py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>(<span class="hljs-params">A, B</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y</span>):</span>
        A.__init__(self, x, y)
        B.__init__(self, x, y)
</code></pre>
<h2>super()</h2>
<p>Mit super:</p>
<pre><code class="hljs language-py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>(<span class="hljs-params">A, B</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y</span>):</span>
        <span class="hljs-built_in">super</span>().__init__(x, y)
</code></pre>
<h1>OOP: Vertiefung</h1>
<h2>Klassendekoration</h2>
<pre><code class="hljs language-py"><span class="hljs-meta">@logattraccess</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>():</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>
        self.a = <span class="hljs-number">3</span>

f = Foo()

f.a <span class="hljs-comment"># prints: "get property 'a'"</span>
f.b = <span class="hljs-number">3</span> <span class="hljs-comment"># prints: "set propery 'b'"</span>
</code></pre>
<h2>Instanzattribute und Slots</h2>
<p>Generell können beliebige Attribute festgesetzt werden:</p>
<pre><code class="hljs language-py">a.value = <span class="hljs-number">3</span>
</code></pre>
<p>Um den Speicherverbrauch zu verringern, können in einer Klasse sogenannte <em>Slots</em> definiert werden:</p>
<pre><code class="hljs language-py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Money</span>():</span>
    __slots__ = [<span class="hljs-string">'currency'</span>, <span class="hljs-string">'amount'</span>]
</code></pre>
<h2>Übungen</h2>
<ul>
<li>Klasse "Vector"</li>
<li>Klasse "BankAccount"</li>
<li>Klasse "Dictionary" (Wörterbuch)</li>
</ul>
<h1>Iterators</h1>
<h2>Iterables und Iterators</h2>
<p><em>Iterable</em>: ein Objekt, über das mittels <code>for element in my_iterable</code> iteriert werden kann</p>
<p><em>Iterator</em>: ein leichtgewichtiges Iterable</p>
<h2>Iterables und Iterators</h2>
<p>Beispiele für Iterables:</p>
<ul>
<li>lists</li>
<li>dicts</li>
<li>range-Objekte</li>
<li>iterators</li>
</ul>
<h2>Iterators</h2>
<p>Ein <em>Iterator</em> ist ein ressourcensparendes Iterable</p>
<p>Mögliche Vorteile eines Iterators gegenüber Listen:</p>
<ul>
<li>Ressourcen werden nur bei Bedarf erstellt / abgefragt</li>
<li>Speicherverbrauch bleibt niedrig (nur je ein Element ist jeweils im Speicher)</li>
</ul>
<h2>Iterators</h2>
<p>Beispiel: <code>open()</code> gibt einen Iterator von Zeilen einer Datei zurück</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"./foo.txt"</span>, encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:
        <span class="hljs-built_in">print</span> line
</code></pre>
<p>Die Datei könnte mehrere GB oder größer sein und dieser Code würde problemlos laufen</p>
<h2>Iterators</h2>
<p>Beispielfunktionen:</p>
<p>Lädt alle Textdateien in <em>./foo/</em> gleichzeitig in eine Liste, iteriert dann über sie:</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> read_textfiles_as_list(<span class="hljs-string">"./foo/"</span>):
    print(text[:<span class="hljs-number">5</span>])
</code></pre>
<p>Lädt Textdateien nacheinander, wodurch der Speicherverbrauch niedrig gehalten wird:</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> read_textfiles_as_iterator(<span class="hljs-string">"./foo/"</span>):
    print(text[:<span class="hljs-number">5</span>])
</code></pre>
<h2>Iterators</h2>
<p>Aufrufe, die Iterators zurückgeben:</p>
<ul>
<li><code>enumerate()</code></li>
<li><code>reversed()</code></li>
<li><code>open()</code></li>
<li><code>os.walk()</code></li>
<li><code>os.scandir()</code></li>
<li><code>map()</code></li>
<li><code>filter()</code></li>
<li>Funktionen in <em>itertools</em></li>
<li>üblicherweise Datenbankcursor (PEP 249)</li>
<li>...</li>
</ul>
<p>Bemerkung: <code>range</code> gibt keinen Iterator zurück (aber ein ähnliches Objekt)</p>
<h2>Itertools</h2>
<p><a href="https://docs.python.org/3/library/itertools.html">itertools</a>: Modul zum erstellen von Iterators</p>
<ul>
<li><code>itertools.count</code></li>
<li><code>itertools.repeat</code></li>
<li><code>itertools.product</code></li>
<li>...</li>
</ul>
<pre><code class="hljs language-py"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> count

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> count():
    print(i)
    <span class="hljs-keyword">if</span> i >= <span class="hljs-number">5</span>:
        <span class="hljs-keyword">break</span>

<span class="hljs-comment"># 0 1 2 3 4 5</span>
</code></pre>
<h1>Generatorfunktionen und Generator Expressions</h1>
<h2>Generatorfunktionen und Generator Expressions</h2>
<p><em>Generatorfunktionen</em> und <em>Generator Expressions</em> sind zwei Möglichkeiten, um selbst <em>Iterators</em> zu erstellen</p>
<h2>Generatorfunktionen</h2>
<p>Eine Funktion kann ein <code>yield</code>-Statement enthalten und wird dadurch zum Generator</p>
<pre><code class="hljs language-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span>():</span>
    i = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-keyword">yield</span> i
        i += i
</code></pre>
<p>Eine Generatorfunktion kann wiederholt verlassen werden (via <code>yield</code>) und wieder betreten werden (durch anfragen des nächsten Werts)</p>
<h2>Übung: lesen von Textdateien in einem Ordner</h2>
<p>Wir erstellen einen Iterator, der die String-Inhalte aller UTF-8-Textdateien in einem Ordner zurückgibt</p>
<p>Verwendung:</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">for</span> content <span class="hljs-keyword">in</span> read_textfiles(<span class="hljs-string">"."</span>):
    print(content[:<span class="hljs-number">10</span>])
</code></pre>
<h2>Übung: lesen von Textdateien in einem Ordner</h2>
<p>Lösung:</p>
<pre><code class="hljs language-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_textfiles</span>(<span class="hljs-params">path=<span class="hljs-string">"."</span></span>):</span>
    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> os.listdir(path):
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path + <span class="hljs-string">"/"</span> + file) <span class="hljs-keyword">as</span> fobj:
                <span class="hljs-keyword">yield</span> fobj.read()
            <span class="hljs-keyword">except</span>:
                <span class="hljs-keyword">pass</span>
</code></pre>
<h2>Generator Expressions</h2>
<p>Generator <em>Expressions</em> sind ähnlich zu List Comprehensions</p>
<p>List comprehension:</p>
<pre><code class="hljs language-py">mylist = [i*i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]
</code></pre>
<p>Generator Expression:</p>
<pre><code class="hljs language-py">mygenerator = (i*i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))
</code></pre>
<h2>Generator Expressions</h2>
<p>Aufsummieren aller Zahlen von 1 bis 10 Millionen:</p>
<p>mittels List Comprehension - dies wird hunderte von Megabyte an RAM verbrauchen (siehe Task Manager):</p>
<pre><code class="hljs language-py"><span class="hljs-built_in">sum</span>([a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10_000_001</span>)])
</code></pre>
<p>mittels Generator Expression:</p>
<pre><code class="hljs language-py"><span class="hljs-built_in">sum</span>((a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10_000_001</span>)))
</code></pre>
<h1>Iterators: Hintergründe</h1>
<h2>Iterators: Hintergründe</h2>
<p>In Python wird jede for-Schleife über einen <em>Iterator</em> durchlaufen.</p>
<p>Wenn eine Iteration über ein iterierbares Objekt ausgeführt wird, wird für diese Iteration ein <em>Iterator</em> erstellt.</p>
<p>Jedes Iterable hat eine <code>__iter__</code>-Methode, die einen Iterator zurückgibt.</p>
<h2>Iterators: Hintergründe</h2>
<p>Ein Iterator besitzt eine <code>__next__</code>-Methode</p>
<p><code>__next__()</code> gibt entweder das nächste Objekt der Iteration zurück oder wirft eine <code>StopIteration</code>-Exception</p>
<p>Ein Iterator is tatsächlich auch immer ein Iterable (hat eine <code>__iter__</code>-Methode, die den Iterator zurückgibt)</p>
<h2>Iterators: Hintergründe</h2>
<p>Iterator einer Liste:</p>
<pre><code class="hljs language-py">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]

numbers_iterator = numbers.__iter__()
</code></pre>
<h2>Iterators: Hintergründe</h2>
<p>Iterators haben eine <code>__next__</code>-Methode, die das nächste Objekt in der Iteration zurückgibt.</p>
<p>Beispiel:</p>
<pre><code class="hljs language-py">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]

numbers_iterator = numbers.__iter__()

print(numbers_iterator.__next__()) <span class="hljs-comment"># 1</span>
print(numbers_iterator.__next__()) <span class="hljs-comment"># 2</span>
</code></pre>
<h2>Iterators: Hintergründe</h2>
<p>Wenn ein Iterator "verbraucht" ist, wird eine <code>StopIteration</code>-Exception ausgelöst:</p>
<pre><code class="hljs language-py">print(numbers_iterator.__next__()) <span class="hljs-comment"># 1</span>
print(numbers_iterator.__next__()) <span class="hljs-comment"># 2</span>
print(numbers_iterator.__next__()) <span class="hljs-comment"># 3</span>
print(numbers_iterator.__next__()) <span class="hljs-comment"># StopIteration</span>
</code></pre>
<h2>Iterators: Hintergründe</h2>
<p>Die globale Funktion <code>next()</code> ist äquivalent zum Aufruf von <code>.__next__()</code></p>
<pre><code class="hljs language-py"><span class="hljs-built_in">next</span>(numbers_iterator)
</code></pre>
<pre><code class="hljs language-py">numbers_iterator.__next__()
</code></pre>
<h2>Iterators: Hintergründe</h2>
<p>Übung: Wir erstellen ein selbstdefiniertes Iterable durch das Implementieren einer klasse mit <code>__iter__</code> und <code>__next__</code></p>
<pre><code class="hljs language-py"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> random():
    ...
</code></pre>
<p>oder</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> roulette():
    print(number, end=<span class="hljs-string">" "</span>)

<span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">29</span> <span class="hljs-number">7</span> <span class="hljs-number">13</span> <span class="hljs-number">19</span>
</code></pre>
<h1>Schleifen</h1>
<h2>for ... else</h2>
<p>Einer for-Schleife kann eine optionale else-Klausel hinzugefügt werden - diese wird ausgeführt, wenn die Schleife ganz durchläuft - wenn also Python während des Ausführens nicht auf ein <code>break</code> (oder <code>return</code> oder ähnliches) stößt.</p>
<h2>for ... else</h2>
<p>Diese Funktionalität gibt es bei keiner anderen verbreiteten Programmiersprache; viele Python-Entwickler kennen sie auch nicht - Zitat vom Erfinder von Python:</p>
<blockquote>
<p>I would not have the feature at all if I had to do it over.</p>
</blockquote>
<h2>Beispiele</h2>
<ul>
<li><code>is_prime()</code> mit Schleifen und <code>for ... else</code></li>
</ul>
<h1>Lambdas</h1>
<h2>Lambdas</h2>
<p>Definieren einer Lambda-Funktion (anonymen Funktion):</p>
<pre><code class="hljs language-py">multiply = <span class="hljs-keyword">lambda</span> a, b: a * b
</code></pre>
<h2>Lambdas</h2>
<p>Verwenden eines Lambdas zum Sortieren:</p>
<pre><code class="hljs language-py">pairs = [(<span class="hljs-number">1</span>, <span class="hljs-string">'one'</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">'two'</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">'three'</span>), (<span class="hljs-number">4</span>, <span class="hljs-string">'four'</span>)]
pairs.sort(key=<span class="hljs-keyword">lambda</span> pair: pair[<span class="hljs-number">1</span>])
</code></pre>
<h1>Funktionen höherer Ordnung</h1>
<h2>Funktionen höherer Ordnung</h2>
<p><em>Funktion höherer Ordnung</em> (<em>higher-order function</em>): eine Funktion, die andere Funktionen als Parameter erhalten kann und/oder eine Funktion zurückgeben kann</p>
<p>wir erinnern uns: "alles ist eine Objekt" in Python - so auch Funktionen</p>
<h2>Functools</h2>
<p>Modul <em>functools</em>: Sammlung von Funktionen höherer Ordnung</p>
<p>Beispiele:</p>
<ul>
<li><code>functools.lru_cache</code></li>
<li><code>functools.cache</code> (Python 3.9)</li>
<li><code>functools.partial</code></li>
<li><code>functools.reduce</code></li>
</ul>
<h2>Functools: partial</h2>
<pre><code class="hljs language-py"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial
open_utf8 = partial(<span class="hljs-built_in">open</span>, encoding=<span class="hljs-string">'utf-8'</span>)
</code></pre>
<h2>Functools: Memoisierung / Caching</h2>
<p><strong>Memoisierung</strong>: Strategie zur Performanceoptimierung:</p>
<p>Die Rückgabewerte bisheriger Funktionsaufrufe werden gespeichert und bei erneutem Aufruf mit den gleichen Parameterwerten wiederverwendet</p>
<pre><code class="hljs language-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fibonacci</span>(<span class="hljs-params">n</span>):</span>
    <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]:
        <span class="hljs-keyword">return</span> n
    <span class="hljs-keyword">return</span> fibonacci(n-<span class="hljs-number">1</span>) + fibonacci(n-<span class="hljs-number">2</span>)

<span class="hljs-comment"># make faster by caching</span>
fibonacci = lru_cache(fibonacci)
</code></pre>
<h2>Decorator-Syntax</h2>
<p>Decorator-Syntax: einfache Möglichkeit, Funktionen höherer Ordnung auf Funktionsdefinitionen anzuwenden</p>
<h2>Decorator-Syntax</h2>
<pre><code class="hljs language-py"><span class="hljs-meta">@lru_cache  </span><span class="hljs-comment"># Python >= 3.8</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fibonacci</span>(<span class="hljs-params">n</span>):</span>
    ...
</code></pre>
<p>äquivalent zu:</p>
<pre><code class="hljs language-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fibonacci</span>(<span class="hljs-params">n</span>):</span>
    ...

fibonacci = lru_cache(fibonacci)
</code></pre>
<h1>Fortgeschrittene Datentypen</h1>
<h2>Fortgeschrittene Datentypen</h2>
<ul>
<li>set / frozenset</li>
<li>NamedTuple</li>
<li>enum</li>
</ul>
<h1>set &#x26; frozenset</h1>
<h2>set &#x26; frozenset</h2>
<p>Set: ungeordnete Menge von Elementen (ohne Duplikate)</p>
<p>Frozenset: unveränderliches set</p>
<pre><code class="hljs language-py">ingredients = {<span class="hljs-string">"flour"</span>, <span class="hljs-string">"water"</span>, <span class="hljs-string">"salt"</span>, <span class="hljs-string">"yeast"</span>}
ingredients = <span class="hljs-built_in">set</span>([<span class="hljs-string">"flour"</span>, <span class="hljs-string">"water"</span>, <span class="hljs-string">"salt"</span>, <span class="hljs-string">"yeast"</span>])
ingredients = <span class="hljs-built_in">frozenset</span>([<span class="hljs-string">"flour"</span>, <span class="hljs-string">"water"</span>, <span class="hljs-string">"salt"</span>, <span class="hljs-string">"yeast"</span>])
</code></pre>
<h2>set</h2>
<p>Sets können insbesondere Listen Ersetzen, wenn die Reihenfolge nicht von Bedeutung sein soll.</p>
<pre><code class="hljs language-py">ingredients1 = {<span class="hljs-string">"flour"</span>, <span class="hljs-string">"water"</span>, <span class="hljs-string">"salt"</span>, <span class="hljs-string">"yeast"</span>}
ingredients2 = {<span class="hljs-string">"water"</span>, <span class="hljs-string">"salt"</span>, <span class="hljs-string">"flour"</span>, <span class="hljs-string">"yeast"</span>}
ingredients1 == ingredients2 <span class="hljs-comment"># True</span>
</code></pre>
<h2>set</h2>
<p>Achtung: Ein leeres set erstellen wir immer mittels <code>set()</code>.</p>
<p>Warum ergibt der Ausdruck <code>{}</code> kein leeres set?</p>
<h2>Operationen auf Sets</h2>
<pre><code class="hljs language-py">x = <span class="hljs-built_in">set</span>(<span class="hljs-string">'abc'</span>)
y = <span class="hljs-built_in">set</span>(<span class="hljs-string">'aeiou'</span>)
x | y
x &#x26; y
x - y
x &#x3C;= y
</code></pre>
<h2>Beispiel: Nachbarländer in Nordamerika</h2>
<pre><code class="hljs language-py">countries = {
    <span class="hljs-string">"Canada"</span>, <span class="hljs-string">"USA"</span>, <span class="hljs-string">"Mexico"</span>, <span class="hljs-string">"Guatemala"</span>, <span class="hljs-string">"Belize"</span>,
    <span class="hljs-string">"El Salvador"</span>, <span class="hljs-string">"Honduras"</span>, <span class="hljs-string">"Nicaragua"</span>, <span class="hljs-string">"Costa Rica"</span>,
    <span class="hljs-string">"Panama"</span>}

neighbors = [
    {<span class="hljs-string">"Canada"</span>, <span class="hljs-string">"USA"</span>},
    {<span class="hljs-string">"USA"</span>, <span class="hljs-string">"Mexico"</span>},
    {<span class="hljs-string">"Mexico"</span>, <span class="hljs-string">"Guatemala"</span>},
    {<span class="hljs-string">"Mexico"</span>, <span class="hljs-string">"Belize"</span>},
    {<span class="hljs-string">"Guatemala"</span>, <span class="hljs-string">"Belize"</span>},
    {<span class="hljs-string">"Guatemala"</span>, <span class="hljs-string">"El Salvador"</span>},
    {<span class="hljs-string">"Guatemala"</span>, <span class="hljs-string">"Honduras"</span>},
    {<span class="hljs-string">"Honduras"</span>, <span class="hljs-string">"Nicaragua"</span>},
    {<span class="hljs-string">"Nicaragua"</span>, <span class="hljs-string">"Costa Rica"</span>},
    {<span class="hljs-string">"Costa Rica"</span>, <span class="hljs-string">"Panama"</span>}
]
</code></pre>
<h2>Aufgabe: "Route" von einem Land in ein anderes</h2>
<h1>namedtuple</h1>
<h2>namedtuple</h2>
<p>Beispiel:</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple

Point = namedtuple(<span class="hljs-string">'Point'</span>, [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>])

p = Point(<span class="hljs-number">11</span>, y=<span class="hljs-number">22</span>)

print(p[<span class="hljs-number">0</span>])
print(p.x)
</code></pre>
<h1>Enum</h1>
<h2>Enum</h2>
<p>Enum = eine Sammlung Symbolischer Namen, die z.B. anstatt vorgegebener Strings verwendet werden kann.</p>
<p>Verwendung eines Strings:</p>
<pre><code class="hljs language-py">a = Button(position=<span class="hljs-string">"left"</span>)
</code></pre>
<p>Verwendung eines Enums namens <em>Position</em>:</p>
<pre><code class="hljs language-py">a = Button(position=Position.LEFT)
</code></pre>
<p>Enums können Tippfehler vermeiden und Autovervollständigung erleichtern.</p>
<h2>Enum</h2>
<p>Definieren eines Enums:</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Position</span>(<span class="hljs-params">Enum</span>):</span>
    UP = <span class="hljs-number">1</span>
    RIGHT = <span class="hljs-number">2</span>
    DOWN = <span class="hljs-number">3</span>
    LEFT = <span class="hljs-number">4</span>
</code></pre>
<h1>Prallelisierung</h1>
<h2>Threads und Multiprocessing - wozu?</h2>
<p>Threads:</p>
<ul>
<li>Warten auf Input / Output (I/O)</li>
<li>Resourcen eines Prozessorkerns gerecht auf verschiedene Aufgaben aufteilen</li>
</ul>
<p>Multiprocessing:</p>
<ul>
<li>Mehrere Prozessorkerne nutzen</li>
</ul>
<p>Vorteil von Threading: einfacher, Variablen können direkt verändert werden</p>
<h2>Threads und Multiprocessing</h2>
<p>generella Arbeitsweise: Wir beauftragen Python damit, einzelne Funktionen in separaten Threads / Prozessen auszuführen, z.B.:</p>
<p>Führe <code>download_xkcd_comic(i)</code> in parallelen Threads für i = 100 - 120 aus</p>
<p>Führe <code>is_prime(i)</code> in parallelen Prozessen für mehrere Zahlen aus und sammle die booleschen Ergebnisse in einer Liste</p>
<h2>Threads und Multiprocessing</h2>
<p>Threads: Python schaltet wiederholt zwischen parallel laufenden Threads um, sodass diese scheinbar parallel laufen; in Wahrheit ist aber zu jedem Zeitpunkt nur ein Thread aktiv (Global Interpreter Lock - GIL)</p>
<p>Multiprocessing: Python startet mehrere Prozesse (sichtbar auch im Taskmanager); Teilen von Werten zwischen Prozessen kann schwerer sein</p>
<h2>Python Interfaces</h2>
<p>high-level:</p>
<ul>
<li><code>concurrent.futures.ThreadPoolExecutor</code></li>
<li><code>concurrent.futures.ProcessPoolExecutor</code></li>
</ul>
<p>low-level:</p>
<ul>
<li><code>threading.Thread</code></li>
<li><code>multiprocessing.Process</code></li>
</ul>
<h2>ThreadPoolExecutor</h2>
<pre><code class="hljs language-py"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_multiple</span>(<span class="hljs-params">text, n</span>):</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        print(text, end=<span class="hljs-string">""</span>)

<span class="hljs-keyword">with</span> ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:
    executor.submit(print_multiple, <span class="hljs-string">"."</span>, <span class="hljs-number">200</span>)
    executor.submit(print_multiple, <span class="hljs-string">"o"</span>, <span class="hljs-number">200</span>)

print(<span class="hljs-string">"completed all tasks"</span>)
</code></pre>
<h2>Übung: Iterationen in Threads</h2>
<p>Wir schreiben ein Programm, das zwei Threads (a und b) ausführt. Die zwei Threads enthalten Schleifen, welche mitzählen, wie oft sie aufgerufen wurden.</p>
<p>Beispielausgabe:</p>
<pre><code class="hljs language-bash">797 iterations <span class="hljs-keyword">in</span> thread a
799 iterations <span class="hljs-keyword">in</span> thread b
1750 iterations <span class="hljs-keyword">in</span> thread a
20254 iterations <span class="hljs-keyword">in</span> thread b
829 iterations <span class="hljs-keyword">in</span> thread a
</code></pre>
<h2>Übung: HTML-Seiten-Downloader via Threads</h2>
<p>Übung: Lade parallel Python Dokumentationsseiten für die folgenden Themen herunter:</p>
<pre><code class="hljs language-json">[<span class="hljs-string">"os"</span>, <span class="hljs-string">"sys"</span>, <span class="hljs-string">"urllib"</span>, <span class="hljs-string">"pprint"</span>, <span class="hljs-string">"math"</span>, <span class="hljs-string">"time"</span>]
</code></pre>
<p>Beispiel-URL: <a href="https://docs.python.org/3/library/os.html">https://docs.python.org/3/library/os.html</a></p>
<p>Die Downloads sollten in einem separaten <em>downloads</em>-Ordner gespeichert werden</p>
<h2>ProcessPoolExecutor</h2>
<p>Programm muss eine Python-Datei sein, die den "Hauptteil" nur dann ausführt, wenn sie selbst direkt ausgeführt - und nicht importiert - wurde (via <code>__name__ == "__main__"</code>)</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">from</span> concurrent.futures.process <span class="hljs-keyword">import</span> ProcessPoolExecutor

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_multiple</span>(<span class="hljs-params">text, n</span>):</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        print(text, end=<span class="hljs-string">""</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-keyword">with</span> ProcessPoolExecutor() <span class="hljs-keyword">as</span> executor:
        executor.submit(print_multiple, <span class="hljs-string">"."</span>, <span class="hljs-number">200</span>)
        executor.submit(print_multiple, <span class="hljs-string">"o"</span>, <span class="hljs-number">200</span>)
</code></pre>
<h2>Map</h2>
<p>Verwendung für die parallele Verarbeitung mehrerer Eingangsdaten zu Ausgangsdaten</p>
<p>Beispiel: Verarbeitung jedes Eintrages in <code>[2, 3, 4, 5, 6]</code>, um zu bestimmen, ob die Zahl eine Primzahl ist → <code>[True, True, False, True, False]</code></p>
<pre><code class="hljs language-py"><span class="hljs-keyword">with</span> ProcessPoolExecutor() <span class="hljs-keyword">as</span> executor:
    prime_indicators = executor.<span class="hljs-built_in">map</span>(is_prime, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])
</code></pre>
<h2>Map</h2>
<p>Übung: Schreibe eine Funktion, die eine Liste von Primzahlen in einem bestimmten Bereich erstellt:</p>
<pre><code class="hljs language-py">prime_range(<span class="hljs-number">100_000_000_000_000</span>, <span class="hljs-number">100_000_000_000_100</span>)
<span class="hljs-comment"># [100000000000031, 100000000000067,</span>
<span class="hljs-comment">#  100000000000097, 100000000000099]</span>
</code></pre>
<p>Verwende einen <code>ProcessPoolExecutor</code> und diese Funktion:</p>
<pre><code class="hljs language-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_prime</span>(<span class="hljs-params">n</span>):</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">int</span>(n**<span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">if</span> n % i == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>