<h1>Datenbanken</h1>
<h2>Datenbanken</h2>
<p>Verwendung: Verwaltung großer Datenmengen</p>
<h2>Datenbanken</h2>
<p>Beispiele:</p>
<ul>
<li>SQL databases
<ul>
<li>MySQL</li>
<li>PostgreSQL</li>
<li>Microsoft SQL Server</li>
<li>SQLite</li>
<li>Oracle</li>
</ul>
</li>
<li>MongoDB</li>
<li>Redis</li>
</ul>
<p><a href="https://insights.stackoverflow.com/survey/2020#technology-databases">Verbreitung laut Stack Overflow Developer Survey 2020</a></p>
<h2>Terminologie</h2>
<ul>
<li><strong>Tabelle / Collection</strong>: Ansammlung ähnlicher Datenobjekte (z.B. eine für Produkte)</li>
<li><strong>Zeile / Eintrag / Dokument</strong>: Einzelner Eintrag in einer Tabelle (z.B. für ein einzelnes Produkt)</li>
<li><strong>Feld</strong>: Ein Wert in einem Eintrag (z.B. <em>Preis</em>)</li>
</ul>
<h2>CRUD-Operationen</h2>
<p>Grundlegende Operationen für Datenbankeinträge:</p>
<ul>
<li><strong>c</strong>reate</li>
<li><strong>r</strong>ead / <strong>r</strong>etrieve</li>
<li><strong>u</strong>pdate</li>
<li><strong>d</strong>elete</li>
</ul>
<h2>Create</h2>
<p>SQL:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> product (<span class="hljs-keyword">name</span>, <span class="hljs-keyword">category</span>)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'IPhone'</span>, <span class="hljs-string">'electronics'</span>)
</code></pre>
<p>MongoDB shell:</p>
<pre><code class="hljs language-js">db.products.insertOne({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'IPhone'</span>,
  <span class="hljs-attr">category</span>: <span class="hljs-string">'electronics'</span>,
});
</code></pre>
<h2>Read</h2>
<p>SQL:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span>, <span class="hljs-keyword">category</span> <span class="hljs-keyword">FROM</span> product
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">category</span> = <span class="hljs-string">'electronics'</span>;
</code></pre>
<p>MongoDB shell:</p>
<pre><code class="hljs language-js">db.products.find({ <span class="hljs-attr">category</span>: <span class="hljs-string">'electronics'</span> });
</code></pre>
<h2>Update</h2>
<p>SQL:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">UPDATE</span> product
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">category</span> = <span class="hljs-string">'phones'</span>
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'IPhone'</span>;
</code></pre>
<p>MongoDB shell:</p>
<pre><code class="hljs language-js">db.products.updateOne(
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'IPhone'</span> },
  { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">category</span>: <span class="hljs-string">'phones'</span> } }
);
</code></pre>
<h2>Delete</h2>
<p>SQL:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> product
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'IPhone'</span>;
</code></pre>
<p>MongoDB shell:</p>
<pre><code class="hljs language-js">db.products.deleteOne({ <span class="hljs-attr">name</span>: <span class="hljs-string">'IPhone'</span> });
</code></pre>
<h2>Online Playgrounds</h2>
<ul>
<li><a href="https://www.w3schools.com/sql/trysql.asp?filename=trysql_select_all">SQL Editor von W3Schools</a> (enthält bereits Daten, verwendbar mit Chrome und Safari)</li>
<li><a href="https://docs.mongodb.com/manual/tutorial/getting-started/">MongoDB Web Shell</a></li>
</ul>
<h2>Übung</h2>
<p>Erstellen / Ändern / Abfragen von Daten in einem Online Playground</p>
<h1>SQL vs MongoDB</h1>
<h2>SQL vs MongoDB</h2>
<p>SQL (Structured Query Language): entwickelt in den 1970ern, viele verschiedene Varianten</p>
<p>MongoDB: 2009 veröffentlicht</p>
<h2>SQL vs MongoDB</h2>
<p>SQL: Einträge werden in Tabellen mit vordefinierten Feldnamen und Feldtypen gespeichert (Datenbankschema)</p>
<p>MongoDB: Einträge (Dokumente) in einer Collection können beliebige Felder haben; optional mit einem <em>Schema</em> validierbar</p>
<h2>SQL vs MongoDB</h2>
<p>SQL: standardisierte Sprache (theoretisch), unabhängig von der verwendeten Programmiersprache</p>
<p>MongoDB: direkte Bindings für Programmiersprachen</p>
<h1>MongoDB Datenformat</h1>
<h2>Datentypen</h2>
<ul>
<li>Zahlen
<ul>
<li>int (32 bit) / long (64 bit)</li>
<li>double (64 bit floating point)</li>
<li>decimal (128 bit)</li>
</ul>
</li>
<li>bool</li>
<li>string</li>
<li>binData</li>
<li>date (Datum + Uhrzeit)</li>
<li>array</li>
<li>object</li>
<li>null</li>
<li>objectId</li>
</ul>
<p>siehe: <a href="https://docs.mongodb.com/manual/reference/bson-types/">https://docs.mongodb.com/manual/reference/bson-types/</a></p>
<h2>ids</h2>
<p>Dokumente bekommen automatisch ein eindeutiges <code>_id</code>-Feld:</p>
<pre><code class="hljs language-js">entry = {
  <span class="hljs-attr">_id</span>: ObjectId(<span class="hljs-string">'5e715e1b31315b0be066db84'</span>),
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Argentina'</span>,
  <span class="hljs-attr">continent</span>: <span class="hljs-string">'South America'</span>,
};
</code></pre>
<h2>BSON Dateiformat</h2>
<p>MongoDB basiert auf dem BSON Dateiformat. Dieses ähnelt JSON, ist aber ein binäres Format und lässt sich effizienter lesen und schreiben.</p>
<p>Der Export bzw Import geschieht mittels der Programme <code>mongodump</code> und <code>mongorestore</code></p>
<h1>MongoDB Shell</h1>
<h2>MongoDB Shell</h2>
<p><strong>MongoDB Shell</strong> = einfaches Befehlszeileninterface für MongoDB</p>
<p>online ausprobieren:</p>
<p><a href="https://docs.mongodb.com/manual/tutorial/getting-started/">https://docs.mongodb.com/manual/tutorial/getting-started/</a></p>
<p>eine Untermenge der MongoDB shell in reinem JavaScript verwenden (ohne Installation von MongoDB):</p>
<p><a href="https://github.com/marko-knoebl/mingodb">https://github.com/marko-knoebl/mingodb</a></p>
<h2>Create</h2>
<p>Erstellen eines Eintrags:</p>
<pre><code class="hljs language-js">db.countries.insertOne({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Argentina'</span>,
  <span class="hljs-attr">continent</span>: <span class="hljs-string">'South America'</span>,
});
</code></pre>
<h2>Create</h2>
<p>Erstellen mehrerer Einträge:</p>
<pre><code class="hljs language-js">db.countries.insertMany([
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Finland'</span>, <span class="hljs-attr">continent</span>: <span class="hljs-string">'Europe'</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Greece'</span>, <span class="hljs-attr">continent</span>: <span class="hljs-string">'Europe'</span> },
]);
</code></pre>
<h2>Read</h2>
<p>Auslesen aller Elemente:</p>
<pre><code class="hljs language-js">db.countries.find();
</code></pre>
<p>Auslesen bestimmter Elemente:</p>
<pre><code class="hljs language-js">db.countries.find({ <span class="hljs-attr">continent</span>: <span class="hljs-string">'Europe'</span> });
</code></pre>
<h2>Read</h2>
<p>Auslesen eines einzelnen Eintrags mittels <code>findOne</code>:</p>
<pre><code class="hljs language-js">db.countries.findOne({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Greece'</span> });
</code></pre>
<h2>Update</h2>
<p>Abändern eines Dokuments - Setzen des Eintrags "population":</p>
<pre><code class="hljs language-js">db.countries.updateOne(
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Argentina'</span> },
  { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">population</span>: <span class="hljs-number">44</span> } }
);
</code></pre>
<h2>Update</h2>
<p>Ersetzen eines Dokuments:</p>
<pre><code class="hljs language-js">db.countries.replaceOne(
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Brazil'</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Brazil'</span>, <span class="hljs-attr">population</span>: <span class="hljs-number">210</span> }
);
</code></pre>
<h2>Delete</h2>
<p>Löschen eines Dokuments:</p>
<pre><code class="hljs language-js">db.countries.deleteOne({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Finland'</span> });
</code></pre>
<p>Löschen aller Einträge:</p>
<pre><code class="hljs language-js">db.countries.deleteMany({});
</code></pre>
<h2>Übung</h2>
<p>Erstellen und Ändern einer Kontaktdatenbank</p>
<h1>SQL Grundlagen</h1>
<h2>SQL</h2>
<p>SQL = Structured Query Language</p>
<p>Standardisierte Abfragesprache für tabellarische Datenbanken</p>
<h2>SQL Standardisierung</h2>
<p>Standardisiert von <em>ANSI</em> und <em>ISO</em> - allerdings weichen Implementierungen oft vom Standard ab</p>
<p>Die beste Unterstützung für standardisiertes SQL bietet wohl <em>PostgreSQL</em></p>
<p>Alte Entwürfe des Standards (kostenlos):</p>
<ul>
<li><a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">SQL 1992 Entwurf (txt, 1.5 MB)</a></li>
<li><a href="www.wiscorp.com/sql20nn.zip">SQL 2011 Entwurf (zip von PDFs, 13 MB)</a></li>
</ul>
<h2>SQL Implementierungen</h2>
<p>open source:</p>
<ul>
<li>MySQL</li>
<li>MariaDB</li>
<li>PostgreSQL</li>
<li>SQLite</li>
</ul>
<p>proprietär:</p>
<ul>
<li>Oracle</li>
<li>SQL Server (Microsoft)</li>
</ul>
<p><a href="https://insights.stackoverflow.com/survey/2019#technology-_-databases">Popularität laut Stackoverflow Developer Survey</a></p>
<h2>SQL ausprobieren</h2>
<p><a href="https://db-fiddle.com">https://db-fiddle.com</a> (PostgreSQL, MySQL, SQLite)</p>
<p><a href="https://www.w3schools.com/sql/trysql.asp?filename=trysql_select_all">https://www.w3schools.com/sql/trysql.asp?filename=trysql_select_all</a> (SQLite)</p>
<p>Desktop-Anwendung:</p>
<p><a href="https://sqlitebrowser.org/">https://sqlitebrowser.org/</a> (SQLite)</p>
<h2>Allgemeine SQL Syntax</h2>
<p>SQL Statements werden mit <code>;</code> beendet</p>
<p>Kommentare sind auf zwei Arten möglich:</p>
<pre><code class="hljs language-sql"><span class="hljs-comment">/* mehrzeiliger
Kommentar */</span>
</code></pre>
<pre><code class="hljs language-sql"><span class="hljs-comment">-- einzeiliger Kommentar</span>
</code></pre>
<h2>Allgemeine SQL Syntax</h2>
<p>SQL ist größtenteils <em>case-insensitive</em></p>
<p>Konvention: Keywords groß geschrieben, Rest meist klein und durch Unterstriche getrennt</p>
<p>Beispiel:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> first_name, last_name, tel <span class="hljs-keyword">FROM</span> person;
</code></pre>
<h2>Allgemeine SQL Syntax</h2>
<p>Tabellen- und Spaltennamen werden von SQL in Großschreibweise konvertiert, z.B. <code>first_name</code> → <code>FIRST_NAME</code>, <code>person</code> → <code>PERSON</code></p>
<p>Ausnahme: In <em>PostgreSQL</em> werden Namen in Kleinschreibweise konvertiert</p>
<h2>Allgemeine SQL Syntax</h2>
<p>Sollen Namen in exakter Schreibweise übernommen werden, müssen sie in Anführungszeichen gesetzt werden. Dies ist eher unüblich.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">"First_Name"</span>, <span class="hljs-string">"Last_Name"</span>, <span class="hljs-string">"Tel"</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">"Person"</span>;
</code></pre>
<p>Ausnahme: In <em>MySQL</em> würden hier Backticks (`) statt Anführungszeichen verwendet werden; hier kann über den Modus <code>ANSI_QUOTES</code> ein Standard-kompatibles Verhalten erreicht werden</p>
<h2>Übungsdaten</h2>
<p><a href="https://github.com/datasets">https://github.com/datasets</a></p>
<h2>Tabellen erstellen</h2>
<p>Befehl: <code>CREATE TABLE</code></p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person(
    <span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">50</span>),
    tel <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>)
);
</code></pre>
<h2>SQL Datentypen</h2>
<p>ISO / ANSI SQL Standard (Auswahl):</p>
<ul>
<li><code>BOOLEAN</code></li>
<li><code>INT</code> / <code>INTEGER</code>, <code>SMALLINT</code>, <code>BIGINT</code></li>
<li><code>NUMERIC</code> / <code>DECIMAL</code></li>
<li><code>REAL</code>, <code>DOUBLE PRECISION</code></li>
<li><code>VARCHAR(n)</code></li>
<li><code>VARBINARY(n)</code></li>
<li><code>DATE</code>, <code>TIME</code>, <code>TIMESTAMP</code></li>
</ul>
<h2>Daten eintragen</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person (<span class="hljs-keyword">name</span>, tel)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'John Smith'</span>, <span class="hljs-string">'012345'</span>);
</code></pre>
<p>Kurzschreibweise:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'John Smith'</span>, <span class="hljs-string">'012345'</span>);
</code></pre>
<h2>Daten auslesen</h2>
<p>Daten aller Personen auslesen</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span>, tel <span class="hljs-keyword">FROM</span> person;
</code></pre>
<p>oder</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person;
</code></pre>
<h2>Bedingte Abfragen (WHERE)</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> tel
<span class="hljs-keyword">FROM</span> person
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'John Smith'</span>;
</code></pre>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> tel
<span class="hljs-keyword">FROM</span> person
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'% Smith'</span>
<span class="hljs-keyword">AND</span> tel <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'+49%'</span>;
</code></pre>
<h2>Daten eintragen (UPDATE)</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">UPDATE</span> person
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'John Miller'</span>
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'John Smith'</span>;
</code></pre>
<h2>Daten löschen (DELETE)</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> person
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'John Miller'</span>;
</code></pre>
<h2>Übung</h2>
<p>Erstellen und Abändern einer Kontaktdatenbank</p>
<h1>MongoDB Schema</h1>
<h2>MongoDB Schema</h2>
<p>Validierung mittels JSON schema, z.B.:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> elementSchema = {
  <span class="hljs-attr">bsonType</span>: <span class="hljs-string">'object'</span>,
  <span class="hljs-attr">required</span>: [
    <span class="hljs-string">'atomic_number'</span>,
    <span class="hljs-string">'symbol'</span>,
    <span class="hljs-string">'name'</span>,
    <span class="hljs-string">'atomic_mass'</span>,
  ],
  <span class="hljs-attr">properties</span>: {
    <span class="hljs-attr">atomic_number</span>: {
      <span class="hljs-attr">bsonType</span>: <span class="hljs-string">'int'</span>,
      <span class="hljs-attr">minimum</span>: <span class="hljs-number">1</span>,
    },
    <span class="hljs-attr">symbol</span>: {
      <span class="hljs-attr">bsonType</span>: <span class="hljs-string">'string'</span>,
    },
    <span class="hljs-attr">name</span>: {
      <span class="hljs-attr">bsonType</span>: <span class="hljs-string">'string'</span>,
    },
    <span class="hljs-attr">atomic_mass</span>: {
      <span class="hljs-attr">bsonType</span>: <span class="hljs-string">'double'</span>,
    },
  },
};
</code></pre>
<h2>MongoDB Schema</h2>
<pre><code class="hljs language-js">db.createCollection(<span class="hljs-string">'elements'</span>, {
  <span class="hljs-attr">validator</span>: { <span class="hljs-attr">$jsonSchema</span>: elementSchema },
});
</code></pre>
<h1>SQL Schema und Indizes</h1>
<h2>Online Tutorial</h2>
<p><a href="https://www.w3schools.com/sql/default.asp">https://www.w3schools.com/sql/default.asp</a></p>
<h2>Wiederholung: SQL Datentypen</h2>
<p>ISO / ANSI SQL Standard (Auswahl):</p>
<ul>
<li><code>BOOLEAN</code></li>
<li><code>INT</code> / <code>INTEGER</code>, <code>SMALLINT</code>, <code>BIGINT</code></li>
<li><code>REAL</code>, <code>DOUBLE PRECISION</code></li>
<li><code>VARCHAR(n)</code></li>
<li><code>VARBINARY(n)</code></li>
<li><code>DATE</code>, <code>TIME</code>, <code>TIMESTAMP</code></li>
</ul>
<h2>Boolean</h2>
<p>Werden durch die Ausdrücke <code>TRUE</code> und <code>FALSE</code> repräsentiert</p>
<p>Abweichungen vom Standard:</p>
<ul>
<li><em>SQL Server</em>: <code>BOOLEAN</code> → <code>BIT</code></li>
<li><em>MySQL</em>, <em>SQLite</em>, <em>Oracle</em>: nicht unterstützt, Alternativen z.B. <code>0</code> und <code>1</code></li>
</ul>
<h2>Zahlen</h2>
<ul>
<li><code>SMALLINT</code> (üblicherweise 16 Bit)</li>
<li><code>INT</code> / <code>INTEGER</code> (üblicherweise 32 Bit)</li>
<li><code>BIGINT</code> (üblicherweise 64 Bit)</li>
<li><code>NUMERIC</code> / <code>DECIMAL</code> (Dezimalzahlen mit variabler Genauigkeit)</li>
<li><code>REAL</code> (üblicherweise 32 Bit)</li>
<li><code>DOUBLE PRECISION</code> (üblicherweise 64 Bit)</li>
</ul>
<p>Abweichungen vom Standard:</p>
<ul>
<li><em>MySQL</em>: <code>REAL</code> → <code>FLOAT</code></li>
<li><em>SQLite</em>: Erlaubt für alle Typen 64 Bit Genauigkeit</li>
</ul>
<h2>Zahlen</h2>
<p>Dezimalzahl mit 10 Stellen vor und 2 Stellen nach dem Komma:</p>
<pre><code class="hljs language-sql">DECIMAL(12, 2)
</code></pre>
<h2>Zahlen</h2>
<p>MySQL unterscheidet z.B. zwischen:</p>
<ul>
<li><code>SMALLINT</code> (-32768 bis 32767)</li>
<li><code>UNSIGNED SMALLINT</code> (0 bis 65535)</li>
</ul>
<p>Dies ist nicht Teil des SQL Standards</p>
<h2>Text</h2>
<ul>
<li><code>VARCHAR(10)</code>: Text der Maximallänge 10</li>
</ul>
<p>Üblicherweise wird Unicode unterstützt</p>
<p>Bei <em>SQL Server</em> sollte für Unicodeunterstütztung <code>NVARCHAR</code> verwendet werden (benötigt doppelt so viel Speicherplatz)</p>
<p>bei <em>Oracle</em> nennt sich der entsprechende Datentyp <code>VARCHAR2</code></p>
<p>Die Maximallänge hat keine Auswirkung auf den Speicherbedarf auf der Festplatte; allerdings kann sie den RAM-Verbrauch beim Lesen und Schreiben beeinflussen</p>
<h2>Text</h2>
<p>Text wird <em>immer</em> mit einfachen Anführungszeichen begrenzt.</p>
<pre><code class="hljs language-SQL"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'Hello'</span>);
</code></pre>
<p>Escapen von einfachen Anführungszeichen durch Verdoppelung:</p>
<pre><code class="hljs language-SQL"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'Let''s go'</span>);
</code></pre>
<h2>Binärdaten</h2>
<p><code>VARBINARY(n)</code>: Bytesequenz mit Maximallänge <em>n</em></p>
<p>Abweichungen vom Standard:</p>
<ul>
<li><em>PostgreSQL</em>: <code>BYTEA</code></li>
<li><em>SQLite</em>: Intern heißt der Datentyp <code>BLOB</code>, aber <code>VARBINARY</code> wird akzeptiert</li>
</ul>
<h2>Date, Time</h2>
<p>Typen:</p>
<ul>
<li><code>DATE</code>: Datum</li>
<li><code>TIME</code>: Uhrzeit</li>
<li><code>TIMESTAMP</code>: Datum und Uhrzeit</li>
</ul>
<p>Beispiele:</p>
<ul>
<li><code>'2013-02-14'</code> (empfohlenes Format)</li>
<li><code>'13:02:17'</code>, <code>'13:02:17.232'</code></li>
<li><code>'2013-02-14 13:02:17'</code>, <code>'2013-02-14T13:02:17'</code></li>
</ul>
<h2>Date, Time</h2>
<p>Abweichungen vom Standard:</p>
<ul>
<li>nicht von <code>SQLite</code> unterstützt</li>
<li><em>SQL Server</em>: <code>TIMESTAMP</code> → <code>DATETIME</code></li>
</ul>
<p>Einschränkungen:</p>
<ul>
<li>in <em>MySQL</em> ist <code>TIMESTAMP</code> auf Jahre zwischen 1970 und 2038 beschränkt - eine bessere Alternative ist <code>DATETIME</code></li>
</ul>
<h2>Resourcen zu Datentypen</h2>
<ul>
<li><a href="https://sqlite.org/datatype3.html">SQLite Datentypen</a></li>
<li><a href="https://www.postgresql.org/docs/current/datatype.html">Postgres Datentypen</a></li>
<li><a href="https://www.postgresql.org/docs/current/features.html">Postgres SQL Conformance</a></li>
</ul>
<h2>Beispiel: Datenbank chemischer Elemente</h2>
<p>Einträge:</p>
<ul>
<li><em>atomic_number</em></li>
<li><em>symbol</em></li>
<li><em>name</em></li>
<li><em>atomic_mass</em></li>
</ul>
<h2>Beispiel: Datenbank chemischer Elemente</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">element</span>(
    atomic_number <span class="hljs-built_in">INT</span>,
    symbol <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">2</span>),
    <span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),
    atomic_mass <span class="hljs-built_in">REAL</span>
);
</code></pre>
<h2>Constraints</h2>
<p>Einschränkungen von Spalten:</p>
<ul>
<li><code>NOT NULL</code></li>
<li><code>UNIQUE</code></li>
<li><code>PRIMARY KEY</code></li>
<li>(<code>FOREIGN KEY</code>)</li>
</ul>
<h2>Not null</h2>
<p>Eintrag darf nicht leer gelassen werden</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">element</span>(
    atomic_number <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
    symbol <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
    <span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
    atomic_mass <span class="hljs-built_in">REAL</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
);
</code></pre>
<h2>Unique</h2>
<p>Jeder Eintrag in einer Spalte muss einzigartig sein</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">element</span>(
    atomic_number <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">UNIQUE</span>,
    symbol <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">UNIQUE</span>,
    <span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">UNIQUE</span>,
    atomic_mass <span class="hljs-built_in">REAL</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
);
</code></pre>
<h2>Primary key</h2>
<p>Ermöglicht eindeutige Identifizierung einer Zeile in einer Tabelle</p>
<ul>
<li>Sprechender Schlüssel: von Haus aus in den Daten enthalten</li>
<li>Surrogatschlüssel: zusätzlich hinzugefügter Schlüssel (meist Integerwert)</li>
</ul>
<p>Ein sprechender Schlüssel ist nur in besonderen Fällen einsetzbar, ein Surrogatschlüssel ist immer möglich</p>
<p>Ein Primary Key ist automatisch <em>unique</em> und <em>not null</em>.</p>
<h2>Primary key</h2>
<p>Sprechender Schlüssel:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">element</span>(
    atomic_number <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>,
    symbol <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">UNIQUE</span>,
    <span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">UNIQUE</span>,
    atomic_mass <span class="hljs-built_in">REAL</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
);
</code></pre>
<h2>Primary key</h2>
<p>Surrogatschlüssel:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">element</span>(
    <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>,
    atomic_numer <span class="hljs-built_in">INT</span>,
    symbol <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">UNIQUE</span>,
    <span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">UNIQUE</span>,
    atomic_mass <span class="hljs-built_in">REAL</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
);
</code></pre>
<h2>Auto increment</h2>
<p>Automatisches Erstellen eines numerischen Primary Keys beginnend bei 1:</p>
<p>Standard SQL (implementiert in PostgreSQL, Oracle):</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">element</span>(
    <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> <span class="hljs-keyword">GENERATED</span> <span class="hljs-keyword">ALWAYS</span> <span class="hljs-keyword">AS</span> <span class="hljs-keyword">IDENTITY</span>;
    ...
);
</code></pre>
<h2>Auto increment</h2>
<p>Nicht-standardisierte Varianten:</p>
<ul>
<li>MySQL: <code>AUTO_INCREMENT</code></li>
<li>SQLite: <code>AUTOINCREMENT</code></li>
<li>PostgreSQL: <code>SERIAL</code></li>
</ul>
<p>In SQLite wird immer automatisch ein numerischer eindeutiger Schlüssel unter dem Namen <code>rowid</code> angelegt.</p>
<h2>Indizes in Datenbanken</h2>
<p>Generell: geordnete Listen können viel schneller durchsucht werden als ungeordnete (binäre Suche)</p>
<p>Beispiel: im Telefonbuch kann man schnell nach dem Nachnamen einer Person suchen, aber nicht nach dem Vornamen</p>
<p>Auf eine oder mehrere Spalten kann ein Index angewendet werden: Zusätzliche Datenstruktur, die auf die Daten in bestimmter Ordnung verweist.</p>
<h2>Indizes erstellen</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_name
<span class="hljs-keyword">ON</span> <span class="hljs-keyword">element</span> (<span class="hljs-keyword">name</span>);
</code></pre>
<p>Es kann nun nach den Elementnamen schneller gesucht werden</p>
<h2>Code: Periodensystem</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">element</span>(
    atomic_number <span class="hljs-built_in">INT</span>,
    symbol <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">UNIQUE</span>,
    <span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">UNIQUE</span>,
    atomic_mass <span class="hljs-built_in">REAL</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
);

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_name
<span class="hljs-keyword">ON</span> <span class="hljs-keyword">element</span> (<span class="hljs-keyword">name</span>);

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">element</span>(atomic_number, symbol, <span class="hljs-keyword">name</span>, atomic_mass)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">'H'</span>, <span class="hljs-string">'Hydrogen'</span>, <span class="hljs-number">1.008</span>);

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">element</span>(atomic_number, symbol, <span class="hljs-keyword">name</span>, atomic_mass)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">'He'</span>, <span class="hljs-string">'Helium'</span>, <span class="hljs-number">4.0026</span>);

<span class="hljs-keyword">SELECT</span> *
<span class="hljs-keyword">FROM</span> <span class="hljs-keyword">element</span>
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'Hydrogen'</span>;
</code></pre>
<h1>SQL vs MongoDB 2</h1>
<h2>SQL vs MongoDB 2</h2>
<p>SQL: Skalierung hauptsächlich vertikal: Hinzufügen von zusätzlichen Resourcen zu einem vorhandenen Server</p>
<p>MongoDB: Skalierung hauptsächlich horizontal: Hinzufügen zusätzlicher Server (via Sharding)</p>
<h2>SQL vs MongoDB 2</h2>
<p>SQL: Verwendet <em>atomare</em> Einträge (und erste Normalform)</p>
<p>MongoDB: Enthält oft zusammengesetzte Einträge (Arrays, Objekte):</p>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"sue"</span>,
  <span class="hljs-attr">"groups"</span>: [<span class="hljs-string">"news"</span>, <span class="hljs-string">"sports"</span>]
}
</code></pre>
<h1>Datenbanken - intermediate</h1>
<h2>Relationen zwischen Tabellen</h2>
<ul>
<li><code>1 : 1</code></li>
<li><code>1 : n</code></li>
<li><code>m : n</code></li>
</ul>
<h2>Relationen zwischen Tabellen: Beispiele</h2>
<ul>
<li><code>0..1 : 1..1</code><br />
department ←manages→ employee<br />
Ein Department hat einen Manager; jeder Angestellte managed entweder 0 oder 1 Department</li>
<li><code>0..1 : 0..n</code><br />
department ←works in→ person<br />
Ein Department kann viele Angestellte haben; ein Angestellter kann 0 oder 1 Department zugeteilt sein</li>
<li><code>0..m : 0..n</code><br />
project ←works on→ person<br />
An einem Projekt können mehrere Angestellte arbeiten; ein Angestellter kann an mehreren Projekten arbeiten</li>
</ul>
<h2>Entity-Relationship-Model</h2>
<p><a href="https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model">https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model</a></p>
<h2>ACID</h2>
<p>Qualitätsmerkmale einer Datenbank (Sicherheit gegenüber Fehlern):</p>
<ul>
<li><em>Atomicity</em>: Daten werden mittels Transaktionen abgeändert, die entweder erfolgreich sind oder als ganzes Fehlschlagen - es wird nie eine Transaktion nur teilweise angewendet</li>
<li><em>Consistency</em>: Für Inhalte können bestimmte Gültigkeitskriterien festgelegt sein - diese können nicht durch Operationen auf den Daten verletzt werden</li>
<li><em>Isolation</em>: Parallel laufende Transaktionen beeinflussen einander nicht</li>
<li><em>Durability</em>: Wenn eine Transaktion vom Datenbanksystem als erfolgreich ausgewiesen wird, muss deren Resultat garantiert dauerhaft vorhanden sein</li>
</ul>
<h1>SQL Joins</h1>
<h2>Beispiel: Musikdatenbank</h2>
<p>Tabellen:</p>
<ul>
<li><em>artist</em></li>
<li><em>album</em></li>
<li><em>song</em></li>
</ul>
<p>Vorlage: Chinook Musikdatenbank</p>
<p><a href="https://github.com/lerocha/chinook-database">GitHub</a></p>
<p><a href="http://schemaspy.org/sample/index.html">Inspektor auf SchemaSpy</a></p>
<h2>Beispiel: Musikdatenbank - artist</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> artist(
    <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> <span class="hljs-keyword">GENERATED</span> <span class="hljs-keyword">ALWAYS</span> <span class="hljs-keyword">AS</span> <span class="hljs-keyword">IDENTITY</span>,
    <span class="hljs-keyword">name</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
    country <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
    <span class="hljs-keyword">year</span> <span class="hljs-built_in">SMALLINT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
);

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> artist (<span class="hljs-keyword">name</span>, country, <span class="hljs-keyword">year</span>)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'The Beatles'</span>, <span class="hljs-string">'UK'</span>, <span class="hljs-number">1960</span>);

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> artist (<span class="hljs-keyword">name</span>, country, <span class="hljs-keyword">year</span>)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'AC/DC'</span>, <span class="hljs-string">'AUS'</span>, <span class="hljs-number">1973</span>);
</code></pre>
<h2>Foreign key</h2>
<p>Referenz auf jeweils einen Eintrag einer anderen Tabelle</p>
<p>z.B.: Jeder Eintrag in der Tabelle <em>song</em> kann über die Spalte <em>artist_id</em> mit der Tabelle <em>artist</em> verknüpft werden</p>
<p>Der Zusatz <code>FOREIGN KEY(column) REFERENCES other_table(column)</code> garantiert, dass ein entsprechender Eintrag in der anderen Tabelle existiert</p>
<h2>Foreign key</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> song(
    <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> <span class="hljs-keyword">GENERATED</span> <span class="hljs-keyword">ALWAYS</span> <span class="hljs-keyword">AS</span> <span class="hljs-keyword">IDENTITY</span>,
    title <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
    artist_id <span class="hljs-built_in">INT</span>,
    <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span>(artist_id) <span class="hljs-keyword">REFERENCES</span> artist(<span class="hljs-keyword">id</span>)
);

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> song (title, artist_id)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'Let it Be'</span>, <span class="hljs-number">1</span>);
</code></pre>
<h2>Foreign key</h2>
<p>Ein foreign key garantiert, dass ein entsprechender Eintrag in der zugehörigen anderen Tabelle existiert</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> song (title, artist_id)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'Wish You Were Here'</span>, <span class="hljs-number">10</span>);
</code></pre>
<p>→ Fehlermeldung</p>
<h2>Tabellen verknüpfen (INNER JOIN)</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> song.title, artist.name
<span class="hljs-keyword">FROM</span> artist
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> song
<span class="hljs-keyword">ON</span> artist.id=song.artist_id;
</code></pre>
<p>Der obige Code listet alle Kombinationen auf, bei denen <code>artist.id</code> und <code>song.artist_id</code> übereinstimmen</p>
<h2>Tabellen verknüpfen (LEFT JOIN)</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> song.title, artist.name
<span class="hljs-keyword">FROM</span> song
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> artist
<span class="hljs-keyword">ON</span> artist.id=song.artist_id;
</code></pre>
<p>Der obige Code listet alle Kombinationen auf und beinhaltet auch Lieder, für die kein Künstler definiert ist</p>
<h1>Datenabfrage - Beispiele</h1>
<h2>Alle Daten abfragen</h2>
<p>SQL:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> iris;
</code></pre>
<p>SQLAlchemy (Python):</p>
<pre><code class="hljs language-sql">session.query(Iris)
</code></pre>
<p>mongo shell (JS):</p>
<pre><code class="hljs language-js">db.iris.find({});
</code></pre>
<p>Pandas (Python): N/A</p>
<h2>Bestimmte Spalten / Felder abfragen</h2>
<p>SQL:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> sepal_length, sepal_width <span class="hljs-keyword">FROM</span> iris;
</code></pre>
<p>SQLAlchemy (Python):</p>
<pre><code class="hljs language-sql">session.query(Iris.sepal_length, Iris.sepal_width)
</code></pre>
<h2>Bestimmte Spalten / Felder abfragen</h2>
<p>Mongo shell:</p>
<pre><code class="hljs language-js">db.iris.find({}, { <span class="hljs-attr">sepal_length</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">sepal_width</span>: <span class="hljs-number">1</span> });
</code></pre>
<p>Pandas:</p>
<pre><code class="hljs language-py">iris_data.loc[:,[<span class="hljs-string">"sepal_length"</span>, <span class="hljs-string">"sepal_width"</span>]]
</code></pre>
<h2>Bestimmte Einträge finden</h2>
<p>SQL:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> iris <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'Iris-setosa'</span>;
</code></pre>
<p>SQLAlchemy (Python):</p>
<pre><code class="hljs language-py">session.query(Iris).<span class="hljs-built_in">filter</span>(Iris.name=<span class="hljs-string">"Iris-setosa"</span>)
</code></pre>
<h2>Bestimmte Einträge finden</h2>
<p>mongo shell:</p>
<pre><code class="hljs language-js">db.iris.find({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Iris-setosa'</span> });
</code></pre>
<p>pandas (Python):</p>
<pre><code class="hljs language-py">iris_setosa_data = iris_data.loc[
    iris_data[<span class="hljs-string">"name"</span>] == <span class="hljs-string">"Iris-setosa"</span>
]
</code></pre>
<p>pandas (Python): Eine Reihe von Einträgen auswählen:</p>
<pre><code class="hljs language-py">iris_data.iloc[<span class="hljs-number">10</span>:<span class="hljs-number">20</span>]
</code></pre>
<h2>Einträge und Felder auswählen</h2>
<p>SQL:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> sepal_length, sepal_width
<span class="hljs-keyword">FROM</span> iris
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'Iris-setosa'</span>;
</code></pre>
<h2>Einträge und Felder auswählen</h2>
<p>SQLAlchemy (Python):</p>
<pre><code class="hljs language-py">session.query(
    Iris.sepal_length, Iris.sepal_width
).<span class="hljs-built_in">filter</span>(Iris.name=<span class="hljs-string">"Iris-setosa"</span>)
</code></pre>
<h2>Einträge und Felder auswählen</h2>
<p>mongo shell:</p>
<pre><code class="hljs language-js">db.iris.find(
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Iris-setosa'</span> },
  { <span class="hljs-attr">sepal_length</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">sepal_width</span>: <span class="hljs-number">1</span> }
);
</code></pre>
<h2>Einträge und Felder auswählen</h2>
<p>pandas (Python):</p>
<pre><code class="hljs language-py">iris_data.loc[
    [iris_data[<span class="hljs-string">"name"</span>] == <span class="hljs-string">"Iris-setosa"</span>],
    [<span class="hljs-string">"sepal_length"</span>, <span class="hljs-string">"sepal_width"</span>],
]
</code></pre>
<h2>Einträge sortieren</h2>
<p>SQL:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> sepal_length, sepal_width
<span class="hljs-keyword">FROM</span> iris
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sepal_length;
</code></pre>
<h2>Einträge sortieren</h2>
<p>SQLAlchemy:</p>
<pre><code class="hljs language-py">session.query(
    Iris.sepal_length, Iris.sepal_width
).order_by(Iris.sepal_length)
</code></pre>
<h2>Einträge sortieren</h2>
<p>mongo shell:</p>
<pre><code class="hljs language-js">db.iris
  .find({}, { <span class="hljs-attr">sepal_length</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">sepal_width</span>: <span class="hljs-number">1</span> })
  .sort({ <span class="hljs-attr">sepal_length</span>: <span class="hljs-number">1</span> });
</code></pre>
<h2>Einträge sortieren</h2>
<p>pandas (Python):</p>
<pre><code class="hljs language-py">iris_data.loc[[<span class="hljs-string">"sepal_length"</span>, <span class="hljs-string">"sepal_width"</span>]].sort_values(
    by=<span class="hljs-string">"sepal_length"</span>
)
</code></pre>