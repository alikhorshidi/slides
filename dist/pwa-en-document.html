<h1>Progressive Web Apps</h1>
<h2>Slides</h2>
<p><a href="https://marko-knoebl.github.io/slides/">https://marko-knoebl.github.io/slides/</a></p>
<h2>Your Trainer</h2>
<p>Marko Knöbl</p>
<ul>
<li>based in Vienna</li>
<li>former math teacher</li>
<li>programming topics:
<ul>
<li>JavaScript, TypeScript and React</li>
<li>Python, data science</li>
</ul>
</li>
</ul>
<h2>Introduction of Participants</h2>
<ul>
<li>current projects</li>
<li>prior knowledge</li>
<li>expectations</li>
</ul>
<h2>Organizational</h2>
<ul>
<li>duration</li>
<li>breaks</li>
<li>lunch</li>
<li>materials</li>
<li>questions, feedback?</li>
</ul>
<h2>Code</h2>
<p>Code available at: <a href="https://github.com/marko-knoebl/courses-code">https://github.com/marko-knoebl/courses-code</a></p>
<h1>Topics</h1>
<h2>Topics - basics</h2>
<ul>
<li>VS Code, Chrome developer tools</li>
<li>modern JavaScript</li>
<li>promises</li>
<li>web workers</li>
</ul>
<h2>Topics</h2>
<ul>
<li>web manifest file</li>
<li>service workers
<ul>
<li>workbox</li>
<li>writing service workers</li>
</ul>
</li>
<li>data storage
<ul>
<li>localStorage</li>
<li>indexedDB</li>
</ul>
</li>
<li>notifications and push notifications</li>
</ul>
<h1>Basics for the course</h1>
<h2>Basics for the course (example: todo-app)</h2>
<ul>
<li>Working with VS Code &#x26; Chrome
<ul>
<li>Prettier</li>
<li>Chrome Dev Tools</li>
</ul>
</li>
<li>ES2015+
<ul>
<li>Modules</li>
<li>Arrow functions</li>
<li>const &#x26; let</li>
</ul>
</li>
<li>running a local dev server</li>
</ul>
<h2>Arbeiten mit VS Code</h2>
<p><a href="./vs-code-en.html">VS Code Basics and Plugins</a></p>
<h2>local HTTP server</h2>
<p>npm package <code>http-server</code></p>
<pre><code class="hljs language-bash">npm install -g http-server
http-server
</code></pre>
<h1>PWA Basics</h1>
<h2>PWA Basics</h2>
<p><a href="https://developers.google.com/web/ilt/pwa/why-build-pwa">https://developers.google.com/web/ilt/pwa/why-build-pwa</a></p>
<ul>
<li>bridge between web and apps</li>
<li>work in the browser, on mobile and on the desktop</li>
<li>web apps that feel like native apps:
<ul>
<li>app icon in the menu (web manifest)</li>
<li>permanent installation and offline use (service workers)</li>
<li>displaying notifications (service workers)</li>
<li>local app data storage (localstorage, indexedDB)</li>
</ul>
</li>
</ul>
<!-- google presentation until page 23 -->
<h2>Browser support</h2>
<p>Service workers:</p>
<p><a href="https://caniuse.com/#search=service%20workers">https://caniuse.com/#search=service%20workers</a></p>
<p>Web app manifest:</p>
<p><a href="https://caniuse.com/#search=manifest">https://caniuse.com/#search=manifest</a></p>
<p>indexedDB:</p>
<p><a href="https://caniuse.com/#search=indexeddb">https://caniuse.com/#search=indexeddb</a></p>
<h2>examples</h2>
<p><a href="https://pwa.rocks">https://pwa.rocks</a></p>
<ul>
<li>wiki offline</li>
<li>telegram</li>
<li>paper planes</li>
</ul>
<h2>Chrome audit</h2>
<p>developer tools - audits</p>
<h1>Service worker basics</h1>
<h2>Service workers - motivation</h2>
<p>Service workers are at the core of PWAs. They are a client-side proxy between the web browser and the server.</p>
<p>Main use case: offline / faster usage of web apps (replaces the deprecated AppCache functionality)</p>
<h2>Service workers - example use cases</h2>
<ul>
<li><em>game</em>: on first load all required resources are downloaded and will be available offline</li>
<li><em>chat app</em>: The avatars of all friends are stored in a cache; they are updated daily</li>
<li><em>wikipedia app</em>: the last 30 visited articles are cached</li>
<li><em>news app</em>: The landing page should be cached and be available immediately on opening the app; afterwards it is updated if possible</li>
</ul>
<h2>Service workers - basic concept</h2>
<h3>traditional web app:</h3>
<p>app ⟺ web server</p>
<h3>PWA:</h3>
<p>app ⟺ service worker ⟺ web server</p>
<h2>Service workers - basic concept</h2>
<p>service woroker = script (web worker) that runs in the background</p>
<p>functionality:</p>
<ul>
<li>caching resources</li>
<li>background sync</li>
<li>push notifications (even when the app is closed)</li>
</ul>
<h2>Registering a service worker</h2>
<p>We call <code>.register()</code> and provide the location of the service worker script</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// main.js</span>
navigator.serviceWorker.register(<span class="hljs-string">'./serviceWorker.js'</span>);
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// serviceWorker.js</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this is the service worker'</span>);
</code></pre>
<h2>Inspecting service workers in the browser tools</h2>
<p>Chrome: developer tools (F12) ➡ <em>Application</em> ➡ <em>Service Workers</em></p>
<p>Firefox: go to <em>about:debugging</em> ➡ <em>this Firefox</em> ➡ <em>Service Workers</em></p>
<h1>Service workers with workbox</h1>
<h2>Service workers with workbox</h2>
<p><strong>Workbox</strong> = Library which simplifies writing service workers</p>
<p><a href="https://developers.google.com/web/tools/workbox/">https://developers.google.com/web/tools/workbox/</a></p>
<h2>Workbox example</h2>
<p>Including a service worker which will cache responses and use them as a fallback if they are not reachable:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// service-worker.js</span>
importScripts(
  <span class="hljs-string">'https://storage.googleapis.com/'</span> +
    <span class="hljs-string">'workbox-cdn/releases/4.1.1/workbox-sw.js'</span>
);

workbox.routing.registerRoute(
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'.*'</span>),
  <span class="hljs-keyword">new</span> workbox.strategies.NetworkFirst()
);
</code></pre>
<!-- this approach is used by create-react-app -->
<h2>Workbox example</h2>
<p>We can inspect the effects of using this service worker in the Chrome developer tools under <em>Application/Service Workers</em> and <em>Application/Cache Storage</em></p>
<h1>Web App Manifest</h1>
<h2>Web App Manifest</h2>
<p>The web app manifest is a json file that provides information on a web app.</p>
<p>Providing a manifest file can enable installation of a PWA.</p>
<h2>Manifest file</h2>
<p>include it via:</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"manifest"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"manifest.json"</span> /></span>
</code></pre>
<h2>Manifest file</h2>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Todo"</span>,
  <span class="hljs-attr">"short_name"</span>: <span class="hljs-string">"Todo"</span>,
  <span class="hljs-attr">"start_url"</span>: <span class="hljs-string">"."</span>,
  <span class="hljs-attr">"display"</span>: <span class="hljs-string">"standalone"</span>,
  <span class="hljs-attr">"icons"</span>: [
    {
      <span class="hljs-attr">"src"</span>: <span class="hljs-string">"images/icon-32.png"</span>,
      <span class="hljs-attr">"sizes"</span>: <span class="hljs-string">"32x32"</span>,
      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"image/png"</span>
    },
    ...
  ]
}
</code></pre>
<h2>Manifest file - entries</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">https://developer.mozilla.org/en-US/docs/Web/Manifest</a></p>
<h2>Manifest file - entries</h2>
<p>crucial entries for Chrome:</p>
<ul>
<li><code>name</code></li>
<li><code>short_name</code></li>
<li><code>start_url</code></li>
<li><code>icons</code> - used in the menu, in the splash screen; for Chrome we should provide square icons of sizes: <code>144</code>, <code>192</code>, <code>512</code></li>
<li><code>display</code>: <code>fullscreen</code> / <code>standalone</code> / <code>minimal-ui</code> / <code>browser</code></li>
</ul>
<h2>Manifest file - entries</h2>
<ul>
<li><code>background_color</code> - should be the same as the app's CSS background color</li>
<li><code>description</code></li>
<li><code>orientation</code>:
<ul>
<li><code>any</code></li>
<li><code>natural</code></li>
<li><code>landscape</code> (<code>landscape-primary</code>, <code>landscape-secondary</code>)</li>
<li><code>portrait</code> (<code>portrait-primary</code>,
<code>portrait-secondary</code>)</li>
</ul>
</li>
<li><code>theme_color</code>:</li>
</ul>
<h2>Meta tags in HTML</h2>
<p>These meta tags are helpful in the browser:</p>
<ul>
<li>in Chrome: Android window color: <code>&#x3C;meta name="theme-color" content="..." /></code> - this should be the same as <code>theme_color</code> in the manifest</li>
<li>on iOS: <code>&#x3C;meta name="apple-mobile-web-app-capable" content="yes"></code> - this hides the browser UI</li>
</ul>
<h1>app installation</h1>
<h2>app installation</h2>
<p>Browsers may offer the ability to add entries to the device's start menu / to the homescreen</p>
<h2>app installation on Chrome and iOS</h2>
<p>In iOS users can add any website to the phone's menu. The mechanism for PWAs is the same.</p>
<p>On Chrome PWAs may prompt the user to be installed. Installed PWAs will behave differently from websites - e.g. they will be displayed in a standalone window.</p>
<h2>app install prompt</h2>
<p>App install prompt on Chrome:</p>
<p><a href="https://developers.google.com/web/fundamentals/app-install-banners/">https://developers.google.com/web/fundamentals/app-install-banners/</a></p>
<h2>app install prompt</h2>
<p>requirements to show the prompt:</p>
<ul>
<li>manifest file includes:
<ul>
<li><em>short_name</em> or <em>name</em></li>
<li>192px and 512px icons</li>
<li><em>start_url</em></li>
<li><em>display</em> must be one of <em>fullscreen</em>, <em>standalone</em>, <em>minimal-ui</em></li>
</ul>
</li>
<li>served via HTTPS</li>
<li>has a service worker (with a fetch event handler)</li>
<li>user has interacted with the domain to some extent</li>
</ul>
<h2>app install prompt</h2>
<p>once all the requirements are met, a <code>beforeinstallprompt</code> event will fire; we can listen for this event and store it for later use</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> installPromptEvent;

<span class="hljs-built_in">window</span>.addEventListener(
  <span class="hljs-string">'beforeinstallprompt'</span>,
  <span class="hljs-function">(<span class="hljs-params">ipEvent</span>) =></span> {
    <span class="hljs-comment">// the browser is ready to show the install prompt</span>
    ipEvent.preventDefault();
    installPromptEvent = ipEvent;
    showInstallBtn();
  }
);
</code></pre>
<h2>app install prompt</h2>
<p>Once the user wants to install the app, we can use the stored event:</p>
<pre><code class="hljs language-js">installBtn.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-comment">// Show the prompt</span>
  installPromptEvent.prompt();
  hideInstallBtn();
});
</code></pre>
<h2>deployment</h2>
<p>hosting options for testing a deployment:</p>
<ul>
<li><a href="https://netlify.com/drop">https://netlify.com/drop</a></li>
<li><a href="https://tiiny.host/">https://tiiny.host/</a> (upload as ZIP file)</li>
</ul>
<h1>Service workers</h1>
<h2>Service workers</h2>
<p>Service workers are client-side proxies between the web browser and the server.</p>
<p>Service workers can cache resources and retrieve them from either the network or the internal cache.</p>
<h2>Service workers</h2>
<p>Service workers are special web workers:</p>
<ul>
<li>no direct access to the DOM</li>
<li>communication with the main thread happens via <code>postMessage</code></li>
</ul>
<h2>Browser support</h2>
<p><a href="https://caniuse.com/##feat=serviceworkers">caniuse</a></p>
<p>support for service workers ⇒ support for ES2015</p>
<h2>Service workers - related technologies</h2>
<ul>
<li>fetch (Sending network requests)</li>
<li>cache (Caching network requests)</li>
</ul>
<h1>Service worker strategies</h1>
<h2>Service workers - strategies</h2>
<p>When deciding on a strategy there are different goals to consider:</p>
<ul>
<li>serve content as fast as possible</li>
<li>serve content which is up-to-date</li>
<li>save on network data usage</li>
<li>save on cache size</li>
</ul>
<h2>Service workers - strategies</h2>
<p>for each resource associated with our web app we should ask ourselves:</p>
<ul>
<li>should we download and cache this resource when the user first visits our page?</li>
<li>if this resource is requested, should we retrieve it from the <em>cache</em> or from the <em>network</em>?</li>
<li>should we fall back to the other option if this fails?</li>
<li>if we serve from the cache, should we try to update it in the background?</li>
</ul>
<p>key questions:</p>
<ul>
<li>for any requested resource, do we serve it from the cache, from the network or a combination?</li>
<li>which resources do we cache and when do we cache them?</li>
</ul>
<h2>Service workers - strategies</h2>
<p>asset retrieval:</p>
<ul>
<li>always from the network</li>
<li>always from the cache</li>
<li>network, falling back to cache</li>
<li>cache, falling back to network</li>
<li>cache, updating the cache from the network in the background</li>
<li>cache, fetching new resource in the background and displaying once received</li>
</ul>
<h2>Service workers - strategies</h2>
<p>caching strategies:</p>
<ul>
<li>cache when new data arrives</li>
<li>precache on install</li>
<li>precache on user interaction</li>
</ul>
<p>(we can combine these strategies)</p>
<h2>Service workers - strategies</h2>
<p>See the <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-then-network">offline cookbook</a></p>
<h1>Workbox in detail</h1>
<h2>Service worker strategies</h2>
<p>Workbox has built-in support for several service worker strategies</p>
<h2>Service worker strategies</h2>
<p>asset retrieval:</p>
<ul>
<li><code>NetworkOnly</code></li>
<li><code>CacheOnly</code></li>
<li><code>NetowrkFirst</code> (cache as fallback)</li>
<li><code>CacheFirst</code> (network as fallback)</li>
<li><code>StaleWhileRevalidate</code> (load from cache, which is updated in the background)</li>
</ul>
<h2>Service worker strategies</h2>
<p>caching:</p>
<ul>
<li>precache on install, always serve this version: <code>precacheAndRoute</code></li>
<li>precache on user interaction: use <code>fetch</code> and the below</li>
<li>cache whenever data arrives: automatic with <code>NetworkFirst</code>, <code>CacheFirst</code>, <code>StaleWhileRevalidate</code></li>
</ul>
<h2>Routing</h2>
<pre><code class="hljs language-js">workbox.routing.registerRoute(
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'/static/.*'</span>),
  <span class="hljs-keyword">new</span> workbox.strategies.CacheFirst()
);

workbox.routing.registerRoute(
  <span class="hljs-string">'/articles.json'</span>,
  <span class="hljs-keyword">new</span> workbox.strategies.NetworkFirst()
);
</code></pre>
<h2>Plugins</h2>
<ul>
<li>expiration plugin (maxEntries, maxAgeSeconds)</li>
</ul>
<h2>Precaching</h2>
<pre><code class="hljs language-js">workbox.precaching.precacheAndRoute([
  <span class="hljs-string">'/'</span>,
  <span class="hljs-string">'/index.html'</span>,
  <span class="hljs-string">'/logo.svg'</span>,
]);
</code></pre>
<h2>CLI</h2>
<p>Workbox CLI: Tool for simplifying precaching in particular</p>
<pre><code class="hljs language-bash">workbox wizard --injectManifest
</code></pre>
<h2>code lab</h2>
<p>~45 min</p>
<p><a href="https://codelabs.developers.google.com/codelabs/workbox-lab/">https://codelabs.developers.google.com/codelabs/workbox-lab/</a></p>
<p>(update version of "workbox-cli" in package.json - older versions will fail on Windows)</p>
<h2>exercises</h2>
<p>Turn one of these apps into a PWA and use various caching strategies:</p>
<ul>
<li><a href="https://github.com/marko-knoebl/simple-todo-app">https://github.com/marko-knoebl/simple-todo-app</a></li>
<li><a href="https://github.com/marko-knoebl/simple-weather-app">https://github.com/marko-knoebl/simple-weather-app</a></li>
<li><a href="https://github.com/marko-knoebl/simple-stock-app">https://github.com/marko-knoebl/simple-stock-app</a></li>
</ul>
<h2>bonus (with build)</h2>
<p><a href="https://developers.google.com/web/tools/workbox/guides/codelabs/npm-script">https://developers.google.com/web/tools/workbox/guides/codelabs/npm-script</a></p>
<h1>Asynchronous JavaScript</h1>
<h2>Asynchronous JavaScript</h2>
<p>see presentation <a href="javascript-async-and-network-requests-en.html">Javascript: async and network requests</a></p>
<h1>Web workers</h1>
<h2>Web workers</h2>
<ul>
<li>enable running a script in the background (in a separate thread)</li>
<li>can be used to run expensive computations - don't block user interaction</li>
</ul>
<h2>Web workers</h2>
<p>creating a worker</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">'worker.js'</span>);
</code></pre>
<h2>Web workers</h2>
<p>listening for messages from the worker</p>
<pre><code class="hljs language-js">worker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>) </span>{
  <span class="hljs-built_in">console</span>.log(message.data);
};
</code></pre>
<h2>Web workers</h2>
<p>passing some task to a worker</p>
<pre><code class="hljs language-js">worker.postMessage(<span class="hljs-number">42</span>);
</code></pre>
<h2>Web workers</h2>
<p>inside the worker:</p>
<pre><code class="hljs language-js">onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>) </span>{
  <span class="hljs-keyword">const</span> result = longComputation(message);
  postMessage(result);
};
</code></pre>
<h2>Web workers</h2>
<p>When passing data to and from web workers: Data are copied and passed as "plain" JavaScript Objects</p>
<h2>Web workers</h2>
<p>Exercise: Fibonacci</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n &#x3C;= <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  }
  <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>);
}
</code></pre>
<h1>Cache overview</h1>
<h2>Cache overview</h2>
<p>= "a request to response map"</p>
<h2>Cache Types</h2>
<p>We can cache resources from both the current domain and other domains;</p>
<p>We can distinguish three types:</p>
<ul>
<li>basic (current domain)</li>
<li>cors (other domain, CORS is enabled)</li>
<li>opaque (other domain, CORS not enabled) - data is not readable from JavaScript</li>
</ul>
<p>Example: see the <em>stock app</em> examples in the Chrome devtools</p>
<h1>Service worker setup</h1>
<h2>Service worker lifecycle</h2>
<ul>
<li>register</li>
<li>install</li>
<li>activate</li>
<li>(unregister)</li>
</ul>
<h2>Registering a service worker</h2>
<p>Any time the page is loaded we call <code>navigator.serviceWorker.register</code> and pass in the URL for the service worker.<br />
If the service worker file is new or has changed it will be installed.</p>
<h2>Registering a service worker</h2>
<pre><code class="hljs language-js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'load'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-comment">// registration can be deferred until</span>
  <span class="hljs-comment">// completion of page load</span>
  <span class="hljs-keyword">if</span> (navigator.serviceWorker) {
    navigator.serviceWorker
      .register(<span class="hljs-string">'/serviceworker.js'</span>)
      .then(<span class="hljs-function"><span class="hljs-params">registration</span> =></span> {
        <span class="hljs-comment">// is executed if there is a *new* sw file</span>
        <span class="hljs-built_in">console</span>.log(
          <span class="hljs-string">`SW registered for <span class="hljs-subst">${registration.scope}</span>`</span>
        );
      })
      .catch(<span class="hljs-comment">/* reg failed */</span>);
  }
});
</code></pre>
<h2>Service worker scope</h2>
<p>By default a service worker will control all requests that lie within its "directory" on the server.</p>
<pre><code class="hljs language-js">navigator.serviceWorker.register(<span class="hljs-string">'/css/serviceworker.js'</span>);
</code></pre>
<p>The SW will control requests to <em>/css/default.css</em>, but not to <em>/index.html</em>.</p>
<p>We can narrow down a service worker to only work on a subpath:</p>
<pre><code class="hljs language-js">navigator.serviceWorker.register(<span class="hljs-string">'/css/serviceworker.js'</span>, {
  <span class="hljs-attr">scope</span>: <span class="hljs-string">'/css/xyz/
})
</span></code></pre>
<h2>Service worker installation</h2>
<p>The service worker's <code>install</code> event occurs when there is a new service worker file:</p>
<ul>
<li>first page visit</li>
<li>the service worker file has changed</li>
</ul>
<p>Good opportunity for downloading and caching resources for later use</p>
<h2>Service worker installaion</h2>
<pre><code class="hljs language-js">self.addEventListener(<span class="hljs-string">'install'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =></span> {
  <span class="hljs-built_in">console</span>.log(event);
});
</code></pre>
<h2>Service worker activation</h2>
<p>If there was no previous version of the service worker, it activates immediately</p>
<p>If there was a previous version, it activates on "restart" (when all corresponding tabs have been closed)</p>
<p>Good opportunity for cleaning up unneeded cached files</p>
<h2>Service worker activation</h2>
<pre><code class="hljs language-js">self.addEventListener(<span class="hljs-string">'activate'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =></span> {
  <span class="hljs-built_in">console</span>.log(event);
});
</code></pre>
<h2>Service worker activation</h2>
<p>We can force immediate activation of a new service worker from the install event:</p>
<pre><code class="hljs language-js">self.addEventListener(<span class="hljs-string">'install'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =></span> {
  self.skipWaiting();
});
</code></pre>
<h2>Uninstalling a service worker</h2>
<p>Uninstalling all service workers for this domain:</p>
<pre><code class="hljs language-js">navigator.serviceWorker
  .getRegistrations()
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">registrations</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> registration <span class="hljs-keyword">of</span> registrations) {
      registration.unregister();
    }
  });
</code></pre>
<h1>Service workers: using fetch</h1>
<h2>The function fetch()</h2>
<pre><code class="hljs language-js"><span class="hljs-comment">// this code can be executed in the</span>
<span class="hljs-comment">// browser console for any website</span>
<span class="hljs-keyword">const</span> url = <span class="hljs-string">'/'</span>;

fetch(url)
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =></span> response.text())
  .then(<span class="hljs-built_in">console</span>.log);
</code></pre>
<h2>Service workers: handling fetch</h2>
<pre><code class="hljs language-js">self.addEventListener(<span class="hljs-string">'fetch'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =></span> {
  event.respondWith(
    <span class="hljs-keyword">new</span> Response(<span class="hljs-string">'All pages look like this'</span>)
  );
});
</code></pre>
<h2>Service workers: handling fetch</h2>
<p>Exercise: We can build a small local website with pages like <em>/home</em>, <em>/about</em>, ...</p>
<h2>Service workers: handling fetch</h2>
<!--
there are two $ signs in regexes in this code
if they are at the very end of the string
they will mess up the result
-->
<pre><code class="hljs language-js">self.addEventListener(<span class="hljs-string">'fetch'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =></span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'/about/$ '</span>).test(event.request.url)) {
    event.respondWith(<span class="hljs-keyword">new</span> Response(<span class="hljs-string">'About'</span>));
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'/a$ '</span>).test(event.request.url)) {
    event.respondWith(<span class="hljs-keyword">new</span> Response(<span class="hljs-string">'Home'</span>));
  } <span class="hljs-keyword">else</span> {
    event.respondWith(<span class="hljs-keyword">new</span> Response(<span class="hljs-string">'404'</span>));
  }
});
</code></pre>
<h2>Service workers: handling fetch</h2>
<p>Exercise: logging all network requests and passing the work on to <code>fetch</code></p>
<h2>Service workers: handling fetch</h2>
<pre><code class="hljs language-js">self.addEventListener(<span class="hljs-string">'fetch'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =></span> {
  <span class="hljs-built_in">console</span>.log(event);
  <span class="hljs-keyword">return</span> fetch(event.request);
});
</code></pre>
<h1>Service workers with fetch and cache</h1>
<h2>Service workers with fetch and cache</h2>
<p>core associated technologies:</p>
<ul>
<li>fetch (sending network requests)</li>
<li>cache (caching results)</li>
</ul>
<h2>Cache</h2>
<p>= "a request to response map"</p>
<h2>Accessing caches</h2>
<p>Via the global variable <code>caches.open</code> or via <code>self.caches.open</code> in the service worker</p>
<p>Promise:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> myCache;
caches.open(<span class="hljs-string">'test'</span>, <span class="hljs-function"><span class="hljs-params">mc</span> =></span> {
  myCache = mc;
});
</code></pre>
<h2>Methods</h2>
<p>cache methods:</p>
<ul>
<li><code>myCache.add(request)</code></li>
<li><code>myCache.addAll(requests)</code></li>
<li><code>myCache.put(request, response)</code></li>
<li><code>myCache.delete(request)</code></li>
<li><code>myCache.match(request)</code></li>
<li><code>myCache.matchAll(requests)</code></li>
</ul>
<p>The <code>request</code> can be either a string or a <code>Request</code> object.</p>
<h2>Cache - add(All)</h2>
<p>We provide a URL; the resource will be automatically requested and stored</p>
<pre><code class="hljs language-js">cache.add(<span class="hljs-string">'/main.js'</span>);

cache.addAll([<span class="hljs-string">'/'</span>, <span class="hljs-string">'/index.html'</span>, <span class="hljs-string">'/main.js'</span>]);
</code></pre>
<h2>Cache - put</h2>
<p>Can be used if we already have the response</p>
<pre><code class="hljs language-js">fetch(<span class="hljs-string">'myurl'</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =></span> {
  <span class="hljs-built_in">console</span>.log(response.clone());
  cache.put(<span class="hljs-string">'myurl'</span>, response.clone());
  cache.put(<span class="hljs-string">'otherurl'</span>, response);
});
</code></pre>
<h2>Cache - delete</h2>
<pre><code class="hljs language-js">cache.delete(<span class="hljs-string">'myurl'</span>);
</code></pre>
<h2>Cache - match</h2>
<p>Retrieve an entry from the cache that matches a request</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// returns a response or undefined</span>
<span class="hljs-keyword">const</span> content = cache.match(<span class="hljs-string">'myurl'</span>);
</code></pre>
<h2>Example: cache only (short)</h2>
<p>An application that will precache resources and always provide them to the user</p>
<pre><code class="hljs language-js">self.addEventListener(<span class="hljs-string">'install'</span>, <span class="hljs-function">() =></span> {
  cache.addAll([<span class="hljs-string">'/'</span>, <span class="hljs-string">'/index.html'</span>, <span class="hljs-string">'/about'</span>])
})

self.addEventListener(<span class="hljs-string">'fetch'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =></span> {
  event.respondWith(
    caches.match(event.request);
  )
})
</code></pre>
<h2>Example: cache only (full code)</h2>
<pre><code class="hljs language-js">self.addEventListener(<span class="hljs-string">'install'</span>, <span class="hljs-function"><span class="hljs-params">installEvent</span> =></span> {
  <span class="hljs-comment">// wait for the cache to be populated;</span>
  <span class="hljs-comment">// abort install on error</span>
  installEvent.waitUntil(
    caches.open(<span class="hljs-string">'app-shell-cache-v3'</span>).then(<span class="hljs-function"><span class="hljs-params">cache</span> =></span> {
      <span class="hljs-keyword">return</span> cache.addAll([<span class="hljs-string">'/'</span>, <span class="hljs-string">'/index.html'</span>, <span class="hljs-string">'/about'</span>]);
    })
  );
  <span class="hljs-comment">// optional - don't abort install on error</span>
  caches.open(<span class="hljs-string">'app-shell-cache-v3'</span>).then(<span class="hljs-function"><span class="hljs-params">cache</span> =></span> {
    cache.addAll[<span class="hljs-string">'/icon1.png'</span>];
  });
});
</code></pre>
<h2>Example: cache only - waitUntil</h2>
<p>A call to <code>waitUntil</code> can be used to signify when the <em>install</em> was successfull - the service worker will only <em>activate</em> if it was</p>
<h2>Example: updating the cache</h2>
<p>deleting old entries:</p>
<pre><code class="hljs language-js">self.addEventListener(<span class="hljs-string">'activate'</span>, <span class="hljs-function"><span class="hljs-params">activateEvent</span> =></span> {
  activateEvent.waitUntil(
    <span class="hljs-built_in">Promise</span>.all([
      caches.delete(<span class="hljs-string">'app-shell-cache-v2'</span>),
      caches.delete(<span class="hljs-string">'app-shell-cache-v1'</span>),
    ])
  );
});
</code></pre>
<h2>Example: retrieve from cache with network fallback</h2>
<pre><code class="hljs language-js">self.addEventListener(<span class="hljs-string">'fetch'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =></span> {
  event.respondWith(
    caches
      .match(event.request)
      .then(<span class="hljs-function"><span class="hljs-params">response</span> =></span> response || fetch(event.request))
  );
});
</code></pre>
<h2>Example: updating the cache on every request</h2>
<pre><code class="hljs language-js">self.addEventListener(<span class="hljs-string">'fetch'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =></span> {
  event.respondWith(
    fetch(event.request).then(<span class="hljs-function"><span class="hljs-params">response</span> =></span> {
      cache.put(event.request, response.clone());
      <span class="hljs-keyword">return</span> response;
    })
  );
});
</code></pre>
<h2>example: network - falling back to cache - falling back to default asset (e.g. user avatar)</h2>
<h2>exercise: scripting the service worker</h2>
<p><a href="https://developers.google.com/web/ilt/pwa/lab-scripting-the-service-worker">https://developers.google.com/web/ilt/pwa/lab-scripting-the-service-worker</a></p>
<h1>The offline cookbook</h1>
<p><a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/">https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/</a></p>
<h1>Data storage</h1>
<h3>localStorage and indexedDB</h3>
<h2>Overview</h2>
<ul>
<li><em>localStorage</em>: simple key-value-store with string values</li>
<li><em>indexedDB</em>: "real database"</li>
</ul>
<h1>localStorage</h1>
<h2>localStorage</h2>
<p><em>localStorage</em> is a simple key-value-store in the browser; both keys and values are strings</p>
<p>The browser stores data separately for each domain</p>
<h2>localStorage</h2>
<p>important methods:</p>
<ul>
<li><code>localStorage.setItem('name', 'John')</code></li>
<li><code>localStorage.getItem('name')</code></li>
<li><code>localStorage.removeItem('name')</code></li>
</ul>
<h2>localStorage</h2>
<p>storing and retrieving some data</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> todoString = <span class="hljs-built_in">JSON</span>.stringify(todos);
<span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">'todos'</span>, todoString);
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> todoString = <span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">'todos'</span>);
todos = <span class="hljs-built_in">JSON</span>.parse(todoString);
</code></pre>
<h1>indexedDB</h1>
<h2>indexedDB</h2>
<p><em>indexedDB</em> is a "real" database</p>
<p>advantages over <em>localStorage</em>:</p>
<ul>
<li>non-blocking</li>
<li>faster (queries via indexes)</li>
<li>separation of data into "tables" (stores)</li>
<li>supports various data types</li>
</ul>
<p>disadvantage: more complicated interface</p>
<h2>indexedDB interfaces</h2>
<ul>
<li>idb</li>
<li>dexie</li>
<li>localForage</li>
</ul>
<h2>indexedDB promised (idb)</h2>
<p>library that enables using indexedDB with Promises</p>
<p><a href="https://github.com/jakearchibald/idb">https://github.com/jakearchibald/idb</a></p>
<p>CDN link: <a href="https://cdn.jsdelivr.net/npm/idb@2.1.2/lib/idb.min.js">https://cdn.jsdelivr.net/npm/idb@2.1.2/lib/idb.min.js</a></p>
<h2>idb basics</h2>
<h2>idb basics: open &#x26; upgrade</h2>
<p>creates / opens a database; returns a promise</p>
<pre><code class="hljs language-js">idb.open(name, version, upgradeCallback);
</code></pre>
<h2>idb basics: open &#x26; upgrade</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> upgradeCallback = <span class="hljs-function"><span class="hljs-params">upgradeDb</span> =></span> {
  <span class="hljs-keyword">if</span> (!upgradeDb.objectStoreNames.contains(<span class="hljs-string">'todos'</span>)) {
    upgradeDb.createObjectStore(<span class="hljs-string">'todos'</span>, {
      <span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">keyPath</span>: <span class="hljs-string">'key'</span>,
    });
  }
};

<span class="hljs-keyword">const</span> dbPromise = idb.open(<span class="hljs-string">'todo-db'</span>, <span class="hljs-number">1</span>, upgradeCallback);
</code></pre>
<h2>idb basics: open &#x26; upgrade</h2>
<p>The last argument (<code>upgradeCallback</code>) can be used to migrate to a new database schema; it can be used to create, delete or change stores</p>
<p>The callback is called any time the version number increases</p>
<h2>idb basics: keys</h2>
<p>Each element in the object store has a unique key (~id)</p>
<p>The key can be an entry in the element or a separate value</p>
<h2>idb basics: keys</h2>
<p>numeric id:</p>
<pre><code class="hljs language-js">upgradeDb.createObjectStore(<span class="hljs-string">'todos'</span>, {
  <span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span>,
});
</code></pre>
<h2>idb basics: keys</h2>
<p>numeric id stored in the object</p>
<pre><code class="hljs language-js">upgradeDb.createObjectStore(<span class="hljs-string">'todos'</span>, {
  <span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">keyPath</span>: <span class="hljs-string">'key
})
</span></code></pre>
<h2>idb basics: keys</h2>
<p>use an entry in the objects as key</p>
<pre><code class="hljs language-js">upgradeDb.createObjectStore(<span class="hljs-string">'users'</span>, {
  <span class="hljs-attr">keyPath</span>: <span class="hljs-string">'email'</span>,
});
</code></pre>
<h2>transactions</h2>
<p>transaction = group of operations on the database (reading, adding, writing, ...)</p>
<h2>transactions</h2>
<p>steps:</p>
<ol>
<li>get the database object (<code>idb.open</code>)</li>
<li>open a transaction on one or more stores (two modes: <code>readonly</code> (default) or <code>readwrite</code>)</li>
<li>open the object store</li>
<li>operate on the object store</li>
</ol>
<h2>transactions</h2>
<p>getting the database object:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> db;

idb.open(<span class="hljs-string">'todo-db'</span>, <span class="hljs-number">1</span>).then(<span class="hljs-function"><span class="hljs-params">openedDb</span> =></span> {
  db = openedDb;
});
</code></pre>
<h2>transactions</h2>
<p>adding data</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> transaction = db.transaction([<span class="hljs-string">'todos'</span>], <span class="hljs-string">'readwrite'</span>);
<span class="hljs-keyword">const</span> todoStore = transaction.objectStore(<span class="hljs-string">'todos'</span>);
todoStore.add({ <span class="hljs-attr">text</span>: <span class="hljs-string">'groceries'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> });
</code></pre>
<h2>transactions</h2>
<p>overwriting data (put)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> transaction = db.transaction([<span class="hljs-string">'todos'</span>], <span class="hljs-string">'readwrite'</span>);
<span class="hljs-keyword">const</span> todoStore = transaction.objectStore(<span class="hljs-string">'todos'</span>);
<span class="hljs-comment">// ersetze den Eintrag mit index 1</span>
todoStore.put({ <span class="hljs-attr">text</span>: <span class="hljs-string">'groceris'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">1</span> });
</code></pre>
<h2>transactions</h2>
<p>deleting data</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> transaction = db.transaction([<span class="hljs-string">'todos'</span>], <span class="hljs-string">'readwrite'</span>);
<span class="hljs-keyword">const</span> todoStore = transaction.objectStore(<span class="hljs-string">'todos'</span>);
todoStore.delete(<span class="hljs-number">1</span>);
</code></pre>
<h2>transactions</h2>
<p>reading data (<code>getAll</code>)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> transaction = db.transaction([<span class="hljs-string">'artists'</span>], <span class="hljs-string">'readonly'</span>);
<span class="hljs-keyword">const</span> artistsStore = transaction.objectStore(<span class="hljs-string">'artists'</span>);
artistsStore.getAll().then(<span class="hljs-built_in">console</span>.log);
</code></pre>
<h2>transactions</h2>
<p>reading data by its key</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> transaction = db.transaction([<span class="hljs-string">'artists'</span>], <span class="hljs-string">'readonly'</span>);
<span class="hljs-keyword">const</span> artistsStore = transaction.objectStore(<span class="hljs-string">'artists'</span>);
artistsStore.get(<span class="hljs-number">1</span>).then(<span class="hljs-built_in">console</span>.log);
</code></pre>
<h2>indexes</h2>
<p>reading data via indexes</p>
<p>Entries in a database are basically stored sorted by their key.</p>
<p>This means it's fast to search for a specific key in the database</p>
<p>Example: In a phone book looking for a last name is fast, but looking for a first name or for a phone number is slow</p>
<h2>indexes</h2>
<p>In order to quickly look up by something other than the primary key: additional index</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> store = upgradeDb.createObjectStore(<span class="hljs-string">'contacts'</span>);
store.createIndex(<span class="hljs-string">'email'</span>, <span class="hljs-string">'email'</span>, { <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span> });
store.createIndex(<span class="hljs-string">'firstName'</span>, <span class="hljs-string">'firstName'</span>);
store.createIndex(<span class="hljs-string">'name'</span>, [<span class="hljs-string">'lastName'</span>, <span class="hljs-string">'firstName'</span>]);
</code></pre>
<h2>indexes</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nameIndex = objectStore.index(<span class="hljs-string">'name'</span>);
nameIndex.get([<span class="hljs-string">'Andy'</span>, <span class="hljs-string">'Jones'</span>]).then(...)
</code></pre>
<h2>exercises</h2>
<ul>
<li>Slides: <a href="https://developers.google.com/web/ilt/pwa/working-with-indexeddb-slides">https://developers.google.com/web/ilt/pwa/working-with-indexeddb-slides</a></li>
<li>Lab: <a href="https://developers.google.com/web/ilt/pwa/lab-indexeddb">https://developers.google.com/web/ilt/pwa/lab-indexeddb</a></li>
</ul>
<h1>Notifications</h1>
<h2>Notifications</h2>
<p>Notification enable displaying messages outside of the app / browser (OS notifications)</p>
<h2>Requesting permission</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> notificationsAllowed;

Notification.requestPermission().then(<span class="hljs-function"><span class="hljs-params">result</span> =></span> {
  <span class="hljs-keyword">if</span> (result === <span class="hljs-string">'granted'</span>) {
    notificationsAllowed = <span class="hljs-literal">true</span>;
  }
});
</code></pre>
<p>This can be tried in the browser console when any web page is open</p>
<h2>Showing notifications</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (Notification.permission === <span class="hljs-string">'granted'</span>) {
  <span class="hljs-keyword">new</span> Notification(<span class="hljs-string">'Hello world'</span>);
}
</code></pre>
<h2>Notification options</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">new</span> Notification(<span class="hljs-string">'cloudy'</span>, {
  <span class="hljs-attr">body</span>: <span class="hljs-string">'The weather in Vienna is cloudy'</span>,
  <span class="hljs-attr">icon</span>: <span class="hljs-string">'static/images/cloudy.png'</span>,
  <span class="hljs-attr">vibrate</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>],
});
</code></pre>
<h2>Resources</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API/Using_the_Notifications_API">MDN: Using the Notifications API</a></li>
</ul>
<h1>Notifications from the service worker</h1>
<h2>Notifications from the service worker</h2>
<p>The notifications we've seen so far originated from one particular browser window. Notifications can also be displayed from the service worker. These notifications will be more capable than the ones we've encountered so far. In particular:</p>
<ul>
<li>Notifications from service workers can provide interactions (Chrome only for now)</li>
<li>Notifications from service workers can be shown when the app / website isn't open</li>
</ul>
<h2>Accessing the service worker registration</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> serviceWorkerRegistration = <span class="hljs-literal">null</span>;

navigator.serviceWorker
  .getRegistration()
  .then(<span class="hljs-function"><span class="hljs-params">registration</span> =></span> {
    serviceWorkerRegistration = registration;
  });
</code></pre>
<h2>Notifications via the service worker</h2>
<pre><code class="hljs language-js">serviceWorkerRegistration.showNotification(<span class="hljs-string">'cloudy'</span>, {
  <span class="hljs-attr">body</span>: <span class="hljs-string">'The weather in Vienna is cloudy'</span>,
  <span class="hljs-attr">icon</span>: <span class="hljs-string">'static/images/cloudy.png'</span>,
  <span class="hljs-attr">vibrate</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>],
  <span class="hljs-comment">// new option available:</span>
  <span class="hljs-attr">actions</span>: [
    { <span class="hljs-attr">action</span>: <span class="hljs-string">'close'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Close'</span> },
    { <span class="hljs-attr">action</span>: <span class="hljs-string">'details'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Details'</span> },
  ],
});
</code></pre>
<h2>listening for notification actions</h2>
<p>two events in the service worker:</p>
<ul>
<li><code>notificationclick</code></li>
<li><code>notificationclose</code></li>
</ul>
<h2>Exercises (labs)</h2>
<p><a href="https://developers.google.com/web/ilt/pwa/lab-integrating-web-push">https://developers.google.com/web/ilt/pwa/lab-integrating-web-push</a></p>
<p>1-3</p>
<p>Removing the service worker in Firefox: about:debugging -> worker</p>
<h1>Push notifications</h1>
<h2>Push notifications</h2>
<ul>
<li>possibility to send messages to a PWA from a server</li>
<li>works even if the app is not currently running (on the desktop at least one browser instance has to be running)</li>
</ul>
<h2>Push notifications - basics</h2>
<figure>
  <svg id="push-message-svg" version="1.1" width="1000" height="500" viewBox="-500 0 1000 500" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <marker id="arrow-end" refX="0.0" refY="0.0" orient="auto" style="overflow: visible;">
      <path transform="rotate(180)" d="M 8.7 4 L -2.2 0 L 8.7 -4 C 7 -1.6 7 1.6 8.7 4 z" class="arrowhead" id="path4877"></path>
    </marker>
  </defs>
  <style>
    #push-message-svg {
      font-family: sans-serif;
    }
    #push-message-svg path.arrow {
      stroke: #000;
      stroke-width: 2;
      marker-end: url(#arrow-end);
    }
    #push-message-svg path.arrowhead {
      fill: #000;
    }
    #push-message-svg text.label {
      font-size: 32px;
      font-family: sans-serif;
      text-anchor: middle;
    }
    # push-message-svg text.label>tspan {
      text-anchor: middle;
    }
    # push-message-svg text.arrowtext {
    font-size: 24px;
  </style>
  <text class="label" transform="translate(0 50)">
    <tspan x="0">
      push
    </tspan>
    <tspan x="0" dy="1.4em">
      service
    </tspan>
  </text>
  <text class="label" transform="translate(-300 430)">
    browser
  </text>
  <text class="label" transform="translate(300 430)">
    application server
  </text>
  <path class="arrow" d="M 300 400 L 20 120" id="path1"></path>
  <text class="arrowtext">
    <textPath href="#path1" side="right" startOffset="15%">
      <tspan y="-8">message &#x26; authentication</tspan>
    </textPath>
  </text>
  <path id="path2" class="arrow" d="M -20 120 L -300 400"></path>
  <text class="arrowtext">
    <textPath href="#path2" side="right" startOffset="40%">
      <tspan y="-8">message</tspan>
    </textPath>
  </text>
</svg>
  <small>best viewed in Firefox</small>
</figure>
<h2>Push notifications - basics</h2>
<p>Push notifications can be sent to a user via the browser vendor (Google, Mozilla, ...). It works via endpoint URLs like these:</p>
<ul>
<li><code>https://android.googleapis.com/gcm/send/IDENTIFIER</code></li>
<li><code>https://updates.push.services.mozilla.com/wpush/v1/IDENTIFIER</code></li>
</ul>
<h2>Push notifications - process</h2>
<figure>
  <svg id="push-message-auth-svg" version="1.1" width="1000" height="500" viewBox="-500 0 1000 500" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <marker id="arrow-end-1" refX="0.0" refY="0.0" orient="auto" style="overflow: visible;">
      <path transform="rotate(180)" d="M 8.7 4 L -2.2 0 L 8.7 -4 C 7 -1.6 7 1.6 8.7 4 z" class="arrowhead" id="path4877"></path>
    </marker>
  </defs>
  <style>
    #push-message-auth-svg {
      font-family: sans-serif;
    }
    #push-message-auth-svg path.arrow {
      stroke: #000;
      stroke-width: 2;
      marker-end: url(#arrow-end-1);
    }
    #push-message-auth-svg path.arrowhead {
      fill: #000;
    }
    #push-message-auth-svg text.label {
      font-size: 32px;
      font-family: sans-serif;
      text-anchor: middle;
    }
    #push-message-auth-svg text.label>tspan {
      text-anchor: middle;
    }
    #push-message-auth-svg text.arrowtext {
    font-size: 24px;
  </style>
  <text class="label" transform="translate(0 50)">
    <tspan x="0">
      push
    </tspan>
    <tspan x="0" dy="1.4em">
      service
    </tspan>
  </text>
  <text class="label" transform="translate(-300 430)">
    browser
  </text>
  <text class="label" transform="translate(300 430)">
    application server
  </text>

  <path id="path1-2" class="arrow" d="M -340 400 L -40 120"></path>
  <text class="arrowtext">
    <textPath href="#path1-2" side="left" startOffset="15%">
      <tspan y="-8">(1) auth request</tspan>
    </textPath>
  </text>

  <path id="path2-2" class="arrow" d="M 0 120 L -300 400 "></path>
  <text class="arrowtext">
    <textPath href="#path2-2" side="right" startOffset="50%">
      <tspan y="-8">(2) auth data</tspan>
    </textPath>
  </text>

  <path id="path3-2" class="arrow" d="M -220 420 L 160 420"></path>
  <text class="arrowtext">
    <textPath href="#path3-2" side="left" startOffset="40%">
      <tspan y="-8">(3) auth data</tspan>
    </textPath>
  </text>
</svg>
  <small>best viewed in Firefox</small>
</figure>
<h2>Push notifications - process</h2>
<ul>
<li>user visits a web app, enables notifications</li>
<li>the web app communicates with the browser vendor (Google, Mozilla, ...); the vendor creates a unique enpoint URL and a public key for encryption and shares them with the browser<br />
The endpoint URL could look like this:
<ul>
<li><code>https://android.googleapis.com/gcm/send/IDENTIFIER</code></li>
<li><code>https://updates.push.services.mozilla.com/wpush/v1/IDENTIFIER</code></li>
</ul>
</li>
<li>the web app shares the endpoint URL and public key with the backend</li>
<li>from the backend, we can now send data to the endpoint URL, encrypted withe the public key. It will be received by the user's service worker</li>
</ul>
<h2>Push notifications - enabling on the client</h2>
<pre><code class="hljs language-js">serviceWorkerRegistration.pushManager
  .subscribe({
    <span class="hljs-attr">userVisibleOnly</span>: <span class="hljs-literal">true</span>,
  })
  .then(<span class="hljs-function">(<span class="hljs-params">subscription</span>) =></span> {
    <span class="hljs-built_in">console</span>.log(subscription.endpoint);
    <span class="hljs-comment">// could be: https://android.googleapis.com/gcm/send/..</span>
  });
</code></pre>
<h2>Push notifications - getting the current subscription</h2>
<pre><code class="hljs language-js">serviceWorkerRegistration.pushManager
  .getSubscription()
  .then(<span class="hljs-function">(<span class="hljs-params">subsription</span>) =></span> {
    <span class="hljs-keyword">if</span> (subscription !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(subscription.toJSON()));
      <span class="hljs-comment">// send the subscription object to our server</span>
    }
  });
</code></pre>
<h2>Push notifications - the subscription object</h2>
<p>Once we obtain this subscription object on the server we can send push messages to the client</p>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">"endpoint"</span>: <span class="hljs-string">"https://android.googleapis.com/gcm/send/f2L..."</span>,
  <span class="hljs-attr">"keys"</span>: {
    <span class="hljs-attr">"auth"</span>: <span class="hljs-string">"5I2BuN..."</span>,
    <span class="hljs-attr">"p256dh"</span>: <span class="hljs-string">"BLc45n..."</span>
  }
}
</code></pre>
<h2>Push Notifications - server</h2>
<p>in node.js:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> webPush = <span class="hljs-built_in">require</span>(<span class="hljs-string">'web-push'</span>);

<span class="hljs-keyword">const</span> subscripton = {
  <span class="hljs-attr">endpoint</span>: <span class="hljs-string">'...'</span>,
  <span class="hljs-attr">keys</span>: { <span class="hljs-attr">auth</span>: <span class="hljs-string">'...'</span>, <span class="hljs-attr">p256dh</span>: <span class="hljs-string">'...'</span> },
};

webPush.sendNotification(subscription, <span class="hljs-string">'Hello world!'</span>);
</code></pre>
<h2>Push Notifications on Chrome</h2>
<p>Push notifications for Chrome are sent via <em>Firebase Cloud Messaging</em> (formerly: <em>Google Cloud Messaging</em>); in order to develop an application that receives push notifications on Chrome we need a firebase account and API key</p>
<pre><code class="hljs language-js">webPush.sendNotification(subscription, <span class="hljs-string">'Hello world!'</span>, {
  <span class="hljs-attr">gcmAPIKey</span>: <span class="hljs-string">'....'</span>,
});
</code></pre>
<h2>Push messages without notifications</h2>
<p>When a push notification arrives via the network the app can react in various ways</p>
<p>Displaying notifications is common but not required by the spec</p>
<p>Chrome currently <em>requires</em> displaying a notification; Firefox has a limit on how many messages can be received without showing notifications</p>
<h2>Push Notifications Lab</h2>
<p><a href="https://developers.google.com/web/ilt/pwa/lab-integrating-web-push">https://developers.google.com/web/ilt/pwa/lab-integrating-web-push</a></p>
<p>1-3</p>
<!--
duration: ca 50 min
-->
<h1>App Stores</h1>
<h2>App Stores</h2>
<p>Publishing PWAs in App Stores</p>
<h2>PWAs in the Google Play Store</h2>
<p>As of February 2019:</p>
<p>TWA = Trusted Web Activity = method of publishing a PWA on the Play Store</p>
<p><a href="https://developers.google.com/web/updates/2019/02/using-twa">https://developers.google.com/web/updates/2019/02/using-twa</a></p>
<p><a href="https://www.youtube.com/watch?v=7JDFjeMvxos">https://www.youtube.com/watch?v=7JDFjeMvxos</a></p>
<p><a href="https://www.youtube.com/watch?v=6lHBw3F4cWs">https://www.youtube.com/watch?v=6lHBw3F4cWs</a></p>
<h2>PWAs in the Microsoft Store</h2>
<p>see <a href="https://www.pwabuilder.com/">https://www.pwabuilder.com/</a></p>
<h2>PWAs in other stores</h2>
<p>PWAs (or HTML apps in general) can be packaged for various stores even if those stores don't natively support PWAs:</p>
<p><a href="https://www.pwabuilder.com/">https://www.pwabuilder.com/</a></p>
<h1>Resources</h1>
<p><a href="https://developers.google.com/web/ilt/pwa/">https://developers.google.com/web/ilt/pwa/</a></p>